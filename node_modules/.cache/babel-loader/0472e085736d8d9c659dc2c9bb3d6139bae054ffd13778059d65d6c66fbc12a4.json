{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _tinycolor = _interopRequireDefault(require(\"tinycolor2\"));\nvar _utils = require(\"@jimp/utils\");\nfunction applyKernel(im, kernel, x, y) {\n  var value = [0, 0, 0];\n  var size = (kernel.length - 1) / 2;\n  for (var kx = 0; kx < kernel.length; kx += 1) {\n    for (var ky = 0; ky < kernel[kx].length; ky += 1) {\n      var idx = im.getPixelIndex(x + kx - size, y + ky - size);\n      value[0] += im.bitmap.data[idx] * kernel[kx][ky];\n      value[1] += im.bitmap.data[idx + 1] * kernel[kx][ky];\n      value[2] += im.bitmap.data[idx + 2] * kernel[kx][ky];\n    }\n  }\n  return value;\n}\nvar isDef = function isDef(v) {\n  return typeof v !== \"undefined\" && v !== null;\n};\nfunction greyscale(cb) {\n  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n    var grey = parseInt(0.2126 * this.bitmap.data[idx] + 0.7152 * this.bitmap.data[idx + 1] + 0.0722 * this.bitmap.data[idx + 2], 10);\n    this.bitmap.data[idx] = grey;\n    this.bitmap.data[idx + 1] = grey;\n    this.bitmap.data[idx + 2] = grey;\n  });\n  if ((0, _utils.isNodePattern)(cb)) {\n    cb.call(this, null, this);\n  }\n  return this;\n}\nfunction mix(clr, clr2) {\n  var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 50;\n  return {\n    r: (clr2.r - clr.r) * (p / 100) + clr.r,\n    g: (clr2.g - clr.g) * (p / 100) + clr.g,\n    b: (clr2.b - clr.b) * (p / 100) + clr.b\n  };\n}\nfunction colorFn(actions, cb) {\n  var _this = this;\n  if (!actions || !Array.isArray(actions)) {\n    return _utils.throwError.call(this, \"actions must be an array\", cb);\n  }\n  actions = actions.map(function (action) {\n    if (action.apply === \"xor\" || action.apply === \"mix\") {\n      action.params[0] = (0, _tinycolor[\"default\"])(action.params[0]).toRgb();\n    }\n    return action;\n  });\n  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n    var clr = {\n      r: _this.bitmap.data[idx],\n      g: _this.bitmap.data[idx + 1],\n      b: _this.bitmap.data[idx + 2]\n    };\n    var colorModifier = function colorModifier(i, amount) {\n      return _this.constructor.limit255(clr[i] + amount);\n    };\n    actions.forEach(function (action) {\n      if (action.apply === \"mix\") {\n        clr = mix(clr, action.params[0], action.params[1]);\n      } else if (action.apply === \"tint\") {\n        clr = mix(clr, {\n          r: 255,\n          g: 255,\n          b: 255\n        }, action.params[0]);\n      } else if (action.apply === \"shade\") {\n        clr = mix(clr, {\n          r: 0,\n          g: 0,\n          b: 0\n        }, action.params[0]);\n      } else if (action.apply === \"xor\") {\n        clr = {\n          r: clr.r ^ action.params[0].r,\n          g: clr.g ^ action.params[0].g,\n          b: clr.b ^ action.params[0].b\n        };\n      } else if (action.apply === \"red\") {\n        clr.r = colorModifier(\"r\", action.params[0]);\n      } else if (action.apply === \"green\") {\n        clr.g = colorModifier(\"g\", action.params[0]);\n      } else if (action.apply === \"blue\") {\n        clr.b = colorModifier(\"b\", action.params[0]);\n      } else {\n        var _clr;\n        if (action.apply === \"hue\") {\n          action.apply = \"spin\";\n        }\n        clr = (0, _tinycolor[\"default\"])(clr);\n        if (!clr[action.apply]) {\n          return _utils.throwError.call(_this, \"action \" + action.apply + \" not supported\", cb);\n        }\n        clr = (_clr = clr)[action.apply].apply(_clr, (0, _toConsumableArray2[\"default\"])(action.params)).toRgb();\n      }\n    });\n    _this.bitmap.data[idx] = clr.r;\n    _this.bitmap.data[idx + 1] = clr.g;\n    _this.bitmap.data[idx + 2] = clr.b;\n  });\n  if ((0, _utils.isNodePattern)(cb)) {\n    cb.call(this, null, this);\n  }\n  return this;\n}\nvar _default = function _default() {\n  return {\n    /**\n     * Adjusts the brightness of the image\n     * @param {number} val the amount to adjust the brightness, a number between -1 and +1\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    brightness: function brightness(val, cb) {\n      if (typeof val !== \"number\") {\n        return _utils.throwError.call(this, \"val must be numbers\", cb);\n      }\n      if (val < -1 || val > +1) {\n        return _utils.throwError.call(this, \"val must be a number between -1 and +1\", cb);\n      }\n      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        if (val < 0.0) {\n          this.bitmap.data[idx] *= 1 + val;\n          this.bitmap.data[idx + 1] *= 1 + val;\n          this.bitmap.data[idx + 2] *= 1 + val;\n        } else {\n          this.bitmap.data[idx] += (255 - this.bitmap.data[idx]) * val;\n          this.bitmap.data[idx + 1] += (255 - this.bitmap.data[idx + 1]) * val;\n          this.bitmap.data[idx + 2] += (255 - this.bitmap.data[idx + 2]) * val;\n        }\n      });\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    },\n    /**\n     * Adjusts the contrast of the image\n     * @param {number} val the amount to adjust the contrast, a number between -1 and +1\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    contrast: function contrast(val, cb) {\n      if (typeof val !== \"number\") {\n        return _utils.throwError.call(this, \"val must be numbers\", cb);\n      }\n      if (val < -1 || val > +1) {\n        return _utils.throwError.call(this, \"val must be a number between -1 and +1\", cb);\n      }\n      var factor = (val + 1) / (1 - val);\n      function adjust(value) {\n        value = Math.floor(factor * (value - 127) + 127);\n        return value < 0 ? 0 : value > 255 ? 255 : value;\n      }\n      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        this.bitmap.data[idx] = adjust(this.bitmap.data[idx]);\n        this.bitmap.data[idx + 1] = adjust(this.bitmap.data[idx + 1]);\n        this.bitmap.data[idx + 2] = adjust(this.bitmap.data[idx + 2]);\n      });\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    },\n    /**\n     * Apply a posterize effect\n     * @param {number} n the amount to adjust the contrast, minimum threshold is two\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    posterize: function posterize(n, cb) {\n      if (typeof n !== \"number\") {\n        return _utils.throwError.call(this, \"n must be numbers\", cb);\n      }\n      if (n < 2) {\n        n = 2;\n      } // minimum of 2 levels\n\n      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        this.bitmap.data[idx] = Math.floor(this.bitmap.data[idx] / 255 * (n - 1)) / (n - 1) * 255;\n        this.bitmap.data[idx + 1] = Math.floor(this.bitmap.data[idx + 1] / 255 * (n - 1)) / (n - 1) * 255;\n        this.bitmap.data[idx + 2] = Math.floor(this.bitmap.data[idx + 2] / 255 * (n - 1)) / (n - 1) * 255;\n      });\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    },\n    /**\n     * Removes colour from the image using ITU Rec 709 luminance values\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    greyscale: greyscale,\n    // Alias of greyscale for our American friends\n    grayscale: greyscale,\n    /**\n     * Multiplies the opacity of each pixel by a factor between 0 and 1\n     * @param {number} f A number, the factor by which to multiply the opacity of each pixel\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    opacity: function opacity(f, cb) {\n      if (typeof f !== \"number\") return _utils.throwError.call(this, \"f must be a number\", cb);\n      if (f < 0 || f > 1) return _utils.throwError.call(this, \"f must be a number from 0 to 1\", cb);\n      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        var v = this.bitmap.data[idx + 3] * f;\n        this.bitmap.data[idx + 3] = v;\n      });\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    },\n    /**\n     * Applies a sepia tone to the image\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    sepia: function sepia(cb) {\n      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        var red = this.bitmap.data[idx];\n        var green = this.bitmap.data[idx + 1];\n        var blue = this.bitmap.data[idx + 2];\n        red = red * 0.393 + green * 0.769 + blue * 0.189;\n        green = red * 0.349 + green * 0.686 + blue * 0.168;\n        blue = red * 0.272 + green * 0.534 + blue * 0.131;\n        this.bitmap.data[idx] = red < 255 ? red : 255;\n        this.bitmap.data[idx + 1] = green < 255 ? green : 255;\n        this.bitmap.data[idx + 2] = blue < 255 ? blue : 255;\n      });\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    },\n    /**\n     * Fades each pixel by a factor between 0 and 1\n     * @param {number} f A number from 0 to 1. 0 will haven no effect. 1 will turn the image completely transparent.\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    fade: function fade(f, cb) {\n      if (typeof f !== \"number\") {\n        return _utils.throwError.call(this, \"f must be a number\", cb);\n      }\n      if (f < 0 || f > 1) {\n        return _utils.throwError.call(this, \"f must be a number from 0 to 1\", cb);\n      } // this method is an alternative to opacity (which may be deprecated)\n\n      this.opacity(1 - f);\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    },\n    /**\n     * Adds each element of the image to its local neighbors, weighted by the kernel\n     * @param {array} kernel a matrix to weight the neighbors sum\n     * @param {number} edgeHandling (optional) define how to sum pixels from outside the border\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    convolution: function convolution(kernel, edgeHandling, cb) {\n      if (typeof edgeHandling === \"function\" && typeof cb === \"undefined\") {\n        cb = edgeHandling;\n        edgeHandling = null;\n      }\n      if (!edgeHandling) {\n        edgeHandling = this.constructor.EDGE_EXTEND;\n      }\n      var newData = Buffer.from(this.bitmap.data);\n      var kRows = kernel.length;\n      var kCols = kernel[0].length;\n      var rowEnd = Math.floor(kRows / 2);\n      var colEnd = Math.floor(kCols / 2);\n      var rowIni = -rowEnd;\n      var colIni = -colEnd;\n      var weight;\n      var rSum;\n      var gSum;\n      var bSum;\n      var ri;\n      var gi;\n      var bi;\n      var xi;\n      var yi;\n      var idxi;\n      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        bSum = 0;\n        gSum = 0;\n        rSum = 0;\n        for (var row = rowIni; row <= rowEnd; row++) {\n          for (var col = colIni; col <= colEnd; col++) {\n            xi = x + col;\n            yi = y + row;\n            weight = kernel[row + rowEnd][col + colEnd];\n            idxi = this.getPixelIndex(xi, yi, edgeHandling);\n            if (idxi === -1) {\n              bi = 0;\n              gi = 0;\n              ri = 0;\n            } else {\n              ri = this.bitmap.data[idxi + 0];\n              gi = this.bitmap.data[idxi + 1];\n              bi = this.bitmap.data[idxi + 2];\n            }\n            rSum += weight * ri;\n            gSum += weight * gi;\n            bSum += weight * bi;\n          }\n        }\n        if (rSum < 0) {\n          rSum = 0;\n        }\n        if (gSum < 0) {\n          gSum = 0;\n        }\n        if (bSum < 0) {\n          bSum = 0;\n        }\n        if (rSum > 255) {\n          rSum = 255;\n        }\n        if (gSum > 255) {\n          gSum = 255;\n        }\n        if (bSum > 255) {\n          bSum = 255;\n        }\n        newData[idx + 0] = rSum;\n        newData[idx + 1] = gSum;\n        newData[idx + 2] = bSum;\n      });\n      this.bitmap.data = newData;\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    },\n    /**\n     * Set the alpha channel on every pixel to fully opaque\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    opaque: function opaque(cb) {\n      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        this.bitmap.data[idx + 3] = 255;\n      });\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    },\n    /**\n     * Pixelates the image or a region\n     * @param {number} size the size of the pixels\n     * @param {number} x (optional) the x position of the region to pixelate\n     * @param {number} y (optional) the y position of the region to pixelate\n     * @param {number} w (optional) the width of the region to pixelate\n     * @param {number} h (optional) the height of the region to pixelate\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    pixelate: function pixelate(size, x, y, w, h, cb) {\n      if (typeof x === \"function\") {\n        cb = x;\n        h = null;\n        w = null;\n        y = null;\n        x = null;\n      } else {\n        if (typeof size !== \"number\") {\n          return _utils.throwError.call(this, \"size must be a number\", cb);\n        }\n        if (isDef(x) && typeof x !== \"number\") {\n          return _utils.throwError.call(this, \"x must be a number\", cb);\n        }\n        if (isDef(y) && typeof y !== \"number\") {\n          return _utils.throwError.call(this, \"y must be a number\", cb);\n        }\n        if (isDef(w) && typeof w !== \"number\") {\n          return _utils.throwError.call(this, \"w must be a number\", cb);\n        }\n        if (isDef(h) && typeof h !== \"number\") {\n          return _utils.throwError.call(this, \"h must be a number\", cb);\n        }\n      }\n      var kernel = [[1 / 16, 2 / 16, 1 / 16], [2 / 16, 4 / 16, 2 / 16], [1 / 16, 2 / 16, 1 / 16]];\n      x = x || 0;\n      y = y || 0;\n      w = isDef(w) ? w : this.bitmap.width - x;\n      h = isDef(h) ? h : this.bitmap.height - y;\n      var source = this.cloneQuiet();\n      this.scanQuiet(x, y, w, h, function (xx, yx, idx) {\n        xx = size * Math.floor(xx / size);\n        yx = size * Math.floor(yx / size);\n        var value = applyKernel(source, kernel, xx, yx);\n        this.bitmap.data[idx] = value[0];\n        this.bitmap.data[idx + 1] = value[1];\n        this.bitmap.data[idx + 2] = value[2];\n      });\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    },\n    /**\n     * Applies a convolution kernel to the image or a region\n     * @param {array} kernel the convolution kernel\n     * @param {number} x (optional) the x position of the region to apply convolution to\n     * @param {number} y (optional) the y position of the region to apply convolution to\n     * @param {number} w (optional) the width of the region to apply convolution to\n     * @param {number} h (optional) the height of the region to apply convolution to\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    convolute: function convolute(kernel, x, y, w, h, cb) {\n      if (!Array.isArray(kernel)) return _utils.throwError.call(this, \"the kernel must be an array\", cb);\n      if (typeof x === \"function\") {\n        cb = x;\n        x = null;\n        y = null;\n        w = null;\n        h = null;\n      } else {\n        if (isDef(x) && typeof x !== \"number\") {\n          return _utils.throwError.call(this, \"x must be a number\", cb);\n        }\n        if (isDef(y) && typeof y !== \"number\") {\n          return _utils.throwError.call(this, \"y must be a number\", cb);\n        }\n        if (isDef(w) && typeof w !== \"number\") {\n          return _utils.throwError.call(this, \"w must be a number\", cb);\n        }\n        if (isDef(h) && typeof h !== \"number\") {\n          return _utils.throwError.call(this, \"h must be a number\", cb);\n        }\n      }\n      var ksize = (kernel.length - 1) / 2;\n      x = isDef(x) ? x : ksize;\n      y = isDef(y) ? y : ksize;\n      w = isDef(w) ? w : this.bitmap.width - x;\n      h = isDef(h) ? h : this.bitmap.height - y;\n      var source = this.cloneQuiet();\n      this.scanQuiet(x, y, w, h, function (xx, yx, idx) {\n        var value = applyKernel(source, kernel, xx, yx);\n        this.bitmap.data[idx] = this.constructor.limit255(value[0]);\n        this.bitmap.data[idx + 1] = this.constructor.limit255(value[1]);\n        this.bitmap.data[idx + 2] = this.constructor.limit255(value[2]);\n      });\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    },\n    /**\n     * Apply multiple color modification rules\n     * @param {array} actions list of color modification rules, in following format: { apply: '<rule-name>', params: [ <rule-parameters> ]  }\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    color: colorFn,\n    colour: colorFn\n  };\n};\nexports[\"default\"] = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["_tinycolor","_interopRequireDefault","require","_utils","applyKernel","im","kernel","x","y","value","size","length","kx","ky","idx","getPixelIndex","bitmap","data","isDef","v","greyscale","cb","scanQuiet","width","height","grey","parseInt","isNodePattern","call","mix","clr","clr2","p","arguments","undefined","r","g","b","colorFn","actions","_this","Array","isArray","throwError","map","action","apply","params","toRgb","colorModifier","i","amount","constructor","limit255","forEach","_clr","_toConsumableArray2","_default","brightness","val","contrast","factor","adjust","Math","floor","posterize","n","grayscale","opacity","f","sepia","red","green","blue","fade","convolution","edgeHandling","EDGE_EXTEND","newData","Buffer","from","kRows","kCols","rowEnd","colEnd","rowIni","colIni","weight","rSum","gSum","bSum","ri","gi","bi","xi","yi","idxi","row","col","opaque","pixelate","w","h","source","cloneQuiet","xx","yx","convolute","ksize","color","colour"],"sources":["/Users/wolfejam/HEXTRA-3/node_modules/@jimp/plugin-color/src/index.js"],"sourcesContent":["import tinyColor from \"tinycolor2\";\nimport { throwError, isNodePattern } from \"@jimp/utils\";\n\nfunction applyKernel(im, kernel, x, y) {\n  const value = [0, 0, 0];\n  const size = (kernel.length - 1) / 2;\n\n  for (let kx = 0; kx < kernel.length; kx += 1) {\n    for (let ky = 0; ky < kernel[kx].length; ky += 1) {\n      const idx = im.getPixelIndex(x + kx - size, y + ky - size);\n\n      value[0] += im.bitmap.data[idx] * kernel[kx][ky];\n      value[1] += im.bitmap.data[idx + 1] * kernel[kx][ky];\n      value[2] += im.bitmap.data[idx + 2] * kernel[kx][ky];\n    }\n  }\n\n  return value;\n}\n\nconst isDef = (v) => typeof v !== \"undefined\" && v !== null;\n\nfunction greyscale(cb) {\n  this.scanQuiet(\n    0,\n    0,\n    this.bitmap.width,\n    this.bitmap.height,\n    function (x, y, idx) {\n      const grey = parseInt(\n        0.2126 * this.bitmap.data[idx] +\n          0.7152 * this.bitmap.data[idx + 1] +\n          0.0722 * this.bitmap.data[idx + 2],\n        10\n      );\n\n      this.bitmap.data[idx] = grey;\n      this.bitmap.data[idx + 1] = grey;\n      this.bitmap.data[idx + 2] = grey;\n    }\n  );\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, this);\n  }\n\n  return this;\n}\n\nfunction mix(clr, clr2, p = 50) {\n  return {\n    r: (clr2.r - clr.r) * (p / 100) + clr.r,\n    g: (clr2.g - clr.g) * (p / 100) + clr.g,\n    b: (clr2.b - clr.b) * (p / 100) + clr.b,\n  };\n}\n\nfunction colorFn(actions, cb) {\n  if (!actions || !Array.isArray(actions)) {\n    return throwError.call(this, \"actions must be an array\", cb);\n  }\n\n  actions = actions.map((action) => {\n    if (action.apply === \"xor\" || action.apply === \"mix\") {\n      action.params[0] = tinyColor(action.params[0]).toRgb();\n    }\n\n    return action;\n  });\n\n  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (x, y, idx) => {\n    let clr = {\n      r: this.bitmap.data[idx],\n      g: this.bitmap.data[idx + 1],\n      b: this.bitmap.data[idx + 2],\n    };\n\n    const colorModifier = (i, amount) =>\n      this.constructor.limit255(clr[i] + amount);\n\n    actions.forEach((action) => {\n      if (action.apply === \"mix\") {\n        clr = mix(clr, action.params[0], action.params[1]);\n      } else if (action.apply === \"tint\") {\n        clr = mix(clr, { r: 255, g: 255, b: 255 }, action.params[0]);\n      } else if (action.apply === \"shade\") {\n        clr = mix(clr, { r: 0, g: 0, b: 0 }, action.params[0]);\n      } else if (action.apply === \"xor\") {\n        clr = {\n          r: clr.r ^ action.params[0].r,\n          g: clr.g ^ action.params[0].g,\n          b: clr.b ^ action.params[0].b,\n        };\n      } else if (action.apply === \"red\") {\n        clr.r = colorModifier(\"r\", action.params[0]);\n      } else if (action.apply === \"green\") {\n        clr.g = colorModifier(\"g\", action.params[0]);\n      } else if (action.apply === \"blue\") {\n        clr.b = colorModifier(\"b\", action.params[0]);\n      } else {\n        if (action.apply === \"hue\") {\n          action.apply = \"spin\";\n        }\n\n        clr = tinyColor(clr);\n\n        if (!clr[action.apply]) {\n          return throwError.call(\n            this,\n            \"action \" + action.apply + \" not supported\",\n            cb\n          );\n        }\n\n        clr = clr[action.apply](...action.params).toRgb();\n      }\n    });\n\n    this.bitmap.data[idx] = clr.r;\n    this.bitmap.data[idx + 1] = clr.g;\n    this.bitmap.data[idx + 2] = clr.b;\n  });\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, this);\n  }\n\n  return this;\n}\n\nexport default () => ({\n  /**\n   * Adjusts the brightness of the image\n   * @param {number} val the amount to adjust the brightness, a number between -1 and +1\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  brightness(val, cb) {\n    if (typeof val !== \"number\") {\n      return throwError.call(this, \"val must be numbers\", cb);\n    }\n\n    if (val < -1 || val > +1) {\n      return throwError.call(\n        this,\n        \"val must be a number between -1 and +1\",\n        cb\n      );\n    }\n\n    this.scanQuiet(\n      0,\n      0,\n      this.bitmap.width,\n      this.bitmap.height,\n      function (x, y, idx) {\n        if (val < 0.0) {\n          this.bitmap.data[idx] *= 1 + val;\n          this.bitmap.data[idx + 1] *= 1 + val;\n          this.bitmap.data[idx + 2] *= 1 + val;\n        } else {\n          this.bitmap.data[idx] += (255 - this.bitmap.data[idx]) * val;\n          this.bitmap.data[idx + 1] += (255 - this.bitmap.data[idx + 1]) * val;\n          this.bitmap.data[idx + 2] += (255 - this.bitmap.data[idx + 2]) * val;\n        }\n      }\n    );\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Adjusts the contrast of the image\n   * @param {number} val the amount to adjust the contrast, a number between -1 and +1\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  contrast(val, cb) {\n    if (typeof val !== \"number\") {\n      return throwError.call(this, \"val must be numbers\", cb);\n    }\n\n    if (val < -1 || val > +1) {\n      return throwError.call(\n        this,\n        \"val must be a number between -1 and +1\",\n        cb\n      );\n    }\n\n    const factor = (val + 1) / (1 - val);\n\n    function adjust(value) {\n      value = Math.floor(factor * (value - 127) + 127);\n\n      return value < 0 ? 0 : value > 255 ? 255 : value;\n    }\n\n    this.scanQuiet(\n      0,\n      0,\n      this.bitmap.width,\n      this.bitmap.height,\n      function (x, y, idx) {\n        this.bitmap.data[idx] = adjust(this.bitmap.data[idx]);\n        this.bitmap.data[idx + 1] = adjust(this.bitmap.data[idx + 1]);\n        this.bitmap.data[idx + 2] = adjust(this.bitmap.data[idx + 2]);\n      }\n    );\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Apply a posterize effect\n   * @param {number} n the amount to adjust the contrast, minimum threshold is two\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  posterize(n, cb) {\n    if (typeof n !== \"number\") {\n      return throwError.call(this, \"n must be numbers\", cb);\n    }\n\n    if (n < 2) {\n      n = 2;\n    } // minimum of 2 levels\n\n    this.scanQuiet(\n      0,\n      0,\n      this.bitmap.width,\n      this.bitmap.height,\n      function (x, y, idx) {\n        this.bitmap.data[idx] =\n          (Math.floor((this.bitmap.data[idx] / 255) * (n - 1)) / (n - 1)) * 255;\n        this.bitmap.data[idx + 1] =\n          (Math.floor((this.bitmap.data[idx + 1] / 255) * (n - 1)) / (n - 1)) *\n          255;\n        this.bitmap.data[idx + 2] =\n          (Math.floor((this.bitmap.data[idx + 2] / 255) * (n - 1)) / (n - 1)) *\n          255;\n      }\n    );\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Removes colour from the image using ITU Rec 709 luminance values\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  greyscale,\n\n  // Alias of greyscale for our American friends\n  grayscale: greyscale,\n\n  /**\n   * Multiplies the opacity of each pixel by a factor between 0 and 1\n   * @param {number} f A number, the factor by which to multiply the opacity of each pixel\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  opacity(f, cb) {\n    if (typeof f !== \"number\")\n      return throwError.call(this, \"f must be a number\", cb);\n    if (f < 0 || f > 1)\n      return throwError.call(this, \"f must be a number from 0 to 1\", cb);\n\n    this.scanQuiet(\n      0,\n      0,\n      this.bitmap.width,\n      this.bitmap.height,\n      function (x, y, idx) {\n        const v = this.bitmap.data[idx + 3] * f;\n        this.bitmap.data[idx + 3] = v;\n      }\n    );\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Applies a sepia tone to the image\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  sepia(cb) {\n    this.scanQuiet(\n      0,\n      0,\n      this.bitmap.width,\n      this.bitmap.height,\n      function (x, y, idx) {\n        let red = this.bitmap.data[idx];\n        let green = this.bitmap.data[idx + 1];\n        let blue = this.bitmap.data[idx + 2];\n\n        red = red * 0.393 + green * 0.769 + blue * 0.189;\n        green = red * 0.349 + green * 0.686 + blue * 0.168;\n        blue = red * 0.272 + green * 0.534 + blue * 0.131;\n\n        this.bitmap.data[idx] = red < 255 ? red : 255;\n        this.bitmap.data[idx + 1] = green < 255 ? green : 255;\n        this.bitmap.data[idx + 2] = blue < 255 ? blue : 255;\n      }\n    );\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Fades each pixel by a factor between 0 and 1\n   * @param {number} f A number from 0 to 1. 0 will haven no effect. 1 will turn the image completely transparent.\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  fade(f, cb) {\n    if (typeof f !== \"number\") {\n      return throwError.call(this, \"f must be a number\", cb);\n    }\n\n    if (f < 0 || f > 1) {\n      return throwError.call(this, \"f must be a number from 0 to 1\", cb);\n    }\n\n    // this method is an alternative to opacity (which may be deprecated)\n    this.opacity(1 - f);\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Adds each element of the image to its local neighbors, weighted by the kernel\n   * @param {array} kernel a matrix to weight the neighbors sum\n   * @param {number} edgeHandling (optional) define how to sum pixels from outside the border\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  convolution(kernel, edgeHandling, cb) {\n    if (typeof edgeHandling === \"function\" && typeof cb === \"undefined\") {\n      cb = edgeHandling;\n      edgeHandling = null;\n    }\n\n    if (!edgeHandling) {\n      edgeHandling = this.constructor.EDGE_EXTEND;\n    }\n\n    const newData = Buffer.from(this.bitmap.data);\n    const kRows = kernel.length;\n    const kCols = kernel[0].length;\n    const rowEnd = Math.floor(kRows / 2);\n    const colEnd = Math.floor(kCols / 2);\n    const rowIni = -rowEnd;\n    const colIni = -colEnd;\n\n    let weight;\n    let rSum;\n    let gSum;\n    let bSum;\n    let ri;\n    let gi;\n    let bi;\n    let xi;\n    let yi;\n    let idxi;\n\n    this.scanQuiet(\n      0,\n      0,\n      this.bitmap.width,\n      this.bitmap.height,\n      function (x, y, idx) {\n        bSum = 0;\n        gSum = 0;\n        rSum = 0;\n\n        for (let row = rowIni; row <= rowEnd; row++) {\n          for (let col = colIni; col <= colEnd; col++) {\n            xi = x + col;\n            yi = y + row;\n            weight = kernel[row + rowEnd][col + colEnd];\n            idxi = this.getPixelIndex(xi, yi, edgeHandling);\n\n            if (idxi === -1) {\n              bi = 0;\n              gi = 0;\n              ri = 0;\n            } else {\n              ri = this.bitmap.data[idxi + 0];\n              gi = this.bitmap.data[idxi + 1];\n              bi = this.bitmap.data[idxi + 2];\n            }\n\n            rSum += weight * ri;\n            gSum += weight * gi;\n            bSum += weight * bi;\n          }\n        }\n\n        if (rSum < 0) {\n          rSum = 0;\n        }\n\n        if (gSum < 0) {\n          gSum = 0;\n        }\n\n        if (bSum < 0) {\n          bSum = 0;\n        }\n\n        if (rSum > 255) {\n          rSum = 255;\n        }\n\n        if (gSum > 255) {\n          gSum = 255;\n        }\n\n        if (bSum > 255) {\n          bSum = 255;\n        }\n\n        newData[idx + 0] = rSum;\n        newData[idx + 1] = gSum;\n        newData[idx + 2] = bSum;\n      }\n    );\n\n    this.bitmap.data = newData;\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Set the alpha channel on every pixel to fully opaque\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  opaque(cb) {\n    this.scanQuiet(\n      0,\n      0,\n      this.bitmap.width,\n      this.bitmap.height,\n      function (x, y, idx) {\n        this.bitmap.data[idx + 3] = 255;\n      }\n    );\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Pixelates the image or a region\n   * @param {number} size the size of the pixels\n   * @param {number} x (optional) the x position of the region to pixelate\n   * @param {number} y (optional) the y position of the region to pixelate\n   * @param {number} w (optional) the width of the region to pixelate\n   * @param {number} h (optional) the height of the region to pixelate\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  pixelate(size, x, y, w, h, cb) {\n    if (typeof x === \"function\") {\n      cb = x;\n      h = null;\n      w = null;\n      y = null;\n      x = null;\n    } else {\n      if (typeof size !== \"number\") {\n        return throwError.call(this, \"size must be a number\", cb);\n      }\n\n      if (isDef(x) && typeof x !== \"number\") {\n        return throwError.call(this, \"x must be a number\", cb);\n      }\n\n      if (isDef(y) && typeof y !== \"number\") {\n        return throwError.call(this, \"y must be a number\", cb);\n      }\n\n      if (isDef(w) && typeof w !== \"number\") {\n        return throwError.call(this, \"w must be a number\", cb);\n      }\n\n      if (isDef(h) && typeof h !== \"number\") {\n        return throwError.call(this, \"h must be a number\", cb);\n      }\n    }\n\n    const kernel = [\n      [1 / 16, 2 / 16, 1 / 16],\n      [2 / 16, 4 / 16, 2 / 16],\n      [1 / 16, 2 / 16, 1 / 16],\n    ];\n\n    x = x || 0;\n    y = y || 0;\n    w = isDef(w) ? w : this.bitmap.width - x;\n    h = isDef(h) ? h : this.bitmap.height - y;\n\n    const source = this.cloneQuiet();\n\n    this.scanQuiet(x, y, w, h, function (xx, yx, idx) {\n      xx = size * Math.floor(xx / size);\n      yx = size * Math.floor(yx / size);\n\n      const value = applyKernel(source, kernel, xx, yx);\n\n      this.bitmap.data[idx] = value[0];\n      this.bitmap.data[idx + 1] = value[1];\n      this.bitmap.data[idx + 2] = value[2];\n    });\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Applies a convolution kernel to the image or a region\n   * @param {array} kernel the convolution kernel\n   * @param {number} x (optional) the x position of the region to apply convolution to\n   * @param {number} y (optional) the y position of the region to apply convolution to\n   * @param {number} w (optional) the width of the region to apply convolution to\n   * @param {number} h (optional) the height of the region to apply convolution to\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  convolute(kernel, x, y, w, h, cb) {\n    if (!Array.isArray(kernel))\n      return throwError.call(this, \"the kernel must be an array\", cb);\n\n    if (typeof x === \"function\") {\n      cb = x;\n      x = null;\n      y = null;\n      w = null;\n      h = null;\n    } else {\n      if (isDef(x) && typeof x !== \"number\") {\n        return throwError.call(this, \"x must be a number\", cb);\n      }\n\n      if (isDef(y) && typeof y !== \"number\") {\n        return throwError.call(this, \"y must be a number\", cb);\n      }\n\n      if (isDef(w) && typeof w !== \"number\") {\n        return throwError.call(this, \"w must be a number\", cb);\n      }\n\n      if (isDef(h) && typeof h !== \"number\") {\n        return throwError.call(this, \"h must be a number\", cb);\n      }\n    }\n\n    const ksize = (kernel.length - 1) / 2;\n\n    x = isDef(x) ? x : ksize;\n    y = isDef(y) ? y : ksize;\n    w = isDef(w) ? w : this.bitmap.width - x;\n    h = isDef(h) ? h : this.bitmap.height - y;\n\n    const source = this.cloneQuiet();\n\n    this.scanQuiet(x, y, w, h, function (xx, yx, idx) {\n      const value = applyKernel(source, kernel, xx, yx);\n\n      this.bitmap.data[idx] = this.constructor.limit255(value[0]);\n      this.bitmap.data[idx + 1] = this.constructor.limit255(value[1]);\n      this.bitmap.data[idx + 2] = this.constructor.limit255(value[2]);\n    });\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Apply multiple color modification rules\n   * @param {array} actions list of color modification rules, in following format: { apply: '<rule-name>', params: [ <rule-parameters> ]  }\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  color: colorFn,\n  colour: colorFn,\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}