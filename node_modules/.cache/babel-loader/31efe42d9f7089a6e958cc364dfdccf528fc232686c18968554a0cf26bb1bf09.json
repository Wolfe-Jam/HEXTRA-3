{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseBitmap = parseBitmap;\nexports.getBuffer = getBuffer;\nexports.getBufferAsync = getBufferAsync;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\nvar _fileType = _interopRequireDefault(require(\"file-type\"));\nvar _exifParser = _interopRequireDefault(require(\"exif-parser\"));\nvar _utils = require(\"@jimp/utils\");\nvar constants = _interopRequireWildcard(require(\"../constants\"));\nvar MIME = _interopRequireWildcard(require(\"./mime\"));\nvar _promisify = _interopRequireDefault(require(\"./promisify\"));\nfunction getMIMEFromBuffer(buffer, path) {\n  var fileTypeFromBuffer;\n  return _regenerator[\"default\"].async(function getMIMEFromBuffer$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return _regenerator[\"default\"].awrap(_fileType[\"default\"].fromBuffer(buffer));\n        case 2:\n          fileTypeFromBuffer = _context.sent;\n          if (!fileTypeFromBuffer) {\n            _context.next = 5;\n            break;\n          }\n          return _context.abrupt(\"return\", fileTypeFromBuffer.mime);\n        case 5:\n          if (!path) {\n            _context.next = 7;\n            break;\n          }\n          return _context.abrupt(\"return\", MIME.getType(path));\n        case 7:\n          return _context.abrupt(\"return\", null);\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  });\n}\n/*\n * Obtains image orientation from EXIF metadata.\n *\n * @param img {Jimp} a Jimp image object\n * @returns {number} a number 1-8 representing EXIF orientation,\n *          in particular 1 if orientation tag is missing\n */\n\nfunction getExifOrientation(img) {\n  return img._exif && img._exif.tags && img._exif.tags.Orientation || 1;\n}\n/**\n * Returns a function which translates EXIF-rotated coordinates into\n * non-rotated ones.\n *\n * Transformation reference: http://sylvana.net/jpegcrop/exif_orientation.html.\n *\n * @param img {Jimp} a Jimp image object\n * @returns {function} transformation function for transformBitmap().\n */\n\nfunction getExifOrientationTransformation(img) {\n  var w = img.getWidth();\n  var h = img.getHeight();\n  switch (getExifOrientation(img)) {\n    case 1:\n      // Horizontal (normal)\n      // does not need to be supported here\n      return null;\n    case 2:\n      // Mirror horizontal\n      return function (x, y) {\n        return [w - x - 1, y];\n      };\n    case 3:\n      // Rotate 180\n      return function (x, y) {\n        return [w - x - 1, h - y - 1];\n      };\n    case 4:\n      // Mirror vertical\n      return function (x, y) {\n        return [x, h - y - 1];\n      };\n    case 5:\n      // Mirror horizontal and rotate 270 CW\n      return function (x, y) {\n        return [y, x];\n      };\n    case 6:\n      // Rotate 90 CW\n      return function (x, y) {\n        return [y, h - x - 1];\n      };\n    case 7:\n      // Mirror horizontal and rotate 90 CW\n      return function (x, y) {\n        return [w - y - 1, h - x - 1];\n      };\n    case 8:\n      // Rotate 270 CW\n      return function (x, y) {\n        return [w - y - 1, x];\n      };\n    default:\n      return null;\n  }\n}\n/*\n * Transforms bitmap in place (moves pixels around) according to given\n * transformation function.\n *\n * @param img {Jimp} a Jimp image object, which bitmap is supposed to\n *        be transformed\n * @param width {number} bitmap width after the transformation\n * @param height {number} bitmap height after the transformation\n * @param transformation {function} transformation function which defines pixel\n *        mapping between new and source bitmap. It takes a pair of coordinates\n *        in the target, and returns a respective pair of coordinates in\n *        the source bitmap, i.e. has following form:\n *        `function(new_x, new_y) { return [src_x, src_y] }`.\n */\n\nfunction transformBitmap(img, width, height, transformation) {\n  // Underscore-prefixed values are related to the source bitmap\n  // Their counterparts with no prefix are related to the target bitmap\n  var _data = img.bitmap.data;\n  var _width = img.bitmap.width;\n  var data = Buffer.alloc(_data.length);\n  for (var x = 0; x < width; x++) {\n    for (var y = 0; y < height; y++) {\n      var _transformation = transformation(x, y),\n        _transformation2 = (0, _slicedToArray2[\"default\"])(_transformation, 2),\n        _x = _transformation2[0],\n        _y = _transformation2[1];\n      var idx = width * y + x << 2;\n      var _idx = _width * _y + _x << 2;\n      var pixel = _data.readUInt32BE(_idx);\n      data.writeUInt32BE(pixel, idx);\n    }\n  }\n  img.bitmap.data = data;\n  img.bitmap.width = width;\n  img.bitmap.height = height;\n}\n/*\n * Automagically rotates an image based on its EXIF data (if present).\n * @param img {Jimp} a Jimp image object\n */\n\nfunction exifRotate(img) {\n  if (getExifOrientation(img) < 2) return;\n  var transformation = getExifOrientationTransformation(img);\n  var swapDimensions = getExifOrientation(img) > 4;\n  var newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;\n  var newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;\n  transformBitmap(img, newWidth, newHeight, transformation);\n} // parses a bitmap from the constructor to the JIMP bitmap property\n\nfunction parseBitmap(data, path, cb) {\n  var mime, _mime;\n  return _regenerator[\"default\"].async(function parseBitmap$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return _regenerator[\"default\"].awrap(getMIMEFromBuffer(data, path));\n        case 2:\n          mime = _context2.sent;\n          if (!(typeof mime !== \"string\")) {\n            _context2.next = 5;\n            break;\n          }\n          return _context2.abrupt(\"return\", cb(new Error(\"Could not find MIME for Buffer <\" + path + \">\")));\n        case 5:\n          this._originalMime = mime.toLowerCase();\n          _context2.prev = 6;\n          _mime = this.getMIME();\n          if (!this.constructor.decoders[_mime]) {\n            _context2.next = 12;\n            break;\n          }\n          this.bitmap = this.constructor.decoders[_mime](data);\n          _context2.next = 13;\n          break;\n        case 12:\n          return _context2.abrupt(\"return\", _utils.throwError.call(this, \"Unsupported MIME type: \" + _mime, cb));\n        case 13:\n          _context2.next = 18;\n          break;\n        case 15:\n          _context2.prev = 15;\n          _context2.t0 = _context2[\"catch\"](6);\n          return _context2.abrupt(\"return\", cb.call(this, _context2.t0, this));\n        case 18:\n          try {\n            this._exif = _exifParser[\"default\"].create(data).parse();\n            exifRotate(this); // EXIF data\n          } catch (error) {\n            /* meh */\n          }\n          cb.call(this, null, this);\n          return _context2.abrupt(\"return\", this);\n        case 21:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, this, [[6, 15]]);\n}\nfunction compositeBitmapOverBackground(Jimp, image) {\n  return new Jimp(image.bitmap.width, image.bitmap.height, image._background).composite(image, 0, 0).bitmap;\n}\n/**\n * Converts the image to a buffer\n * @param {string} mime the mime type of the image buffer to be created\n * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n * @returns {Jimp} this for chaining of methods\n */\n\nfunction getBuffer(mime, cb) {\n  if (mime === constants.AUTO) {\n    // allow auto MIME detection\n    mime = this.getMIME();\n  }\n  if (typeof mime !== \"string\") {\n    return _utils.throwError.call(this, \"mime must be a string\", cb);\n  }\n  if (typeof cb !== \"function\") {\n    return _utils.throwError.call(this, \"cb must be a function\", cb);\n  }\n  mime = mime.toLowerCase();\n  if (this._rgba && this.constructor.hasAlpha[mime]) {\n    this.bitmap.data = Buffer.from(this.bitmap.data);\n  } else {\n    // when format doesn't support alpha\n    // composite onto a new image so that the background shows through alpha channels\n    this.bitmap.data = compositeBitmapOverBackground(this.constructor, this).data;\n  }\n  if (this.constructor.encoders[mime]) {\n    var buffer = this.constructor.encoders[mime](this);\n    cb.call(this, null, buffer);\n  } else {\n    cb.call(this, \"Unsupported MIME type: \" + mime);\n  }\n  return this;\n}\nfunction getBufferAsync(mime) {\n  return (0, _promisify[\"default\"])(getBuffer, this, mime);\n}","map":{"version":3,"names":["_fileType","_interopRequireDefault","require","_exifParser","_utils","constants","_interopRequireWildcard","MIME","_promisify","getMIMEFromBuffer","buffer","path","fileTypeFromBuffer","_regenerator","async","getMIMEFromBuffer$","_context","prev","next","awrap","fromBuffer","sent","abrupt","mime","getType","stop","getExifOrientation","img","_exif","tags","Orientation","getExifOrientationTransformation","w","getWidth","h","getHeight","x","y","transformBitmap","width","height","transformation","_data","bitmap","data","_width","Buffer","alloc","length","_transformation","_transformation2","_slicedToArray2","_x","_y","idx","_idx","pixel","readUInt32BE","writeUInt32BE","exifRotate","swapDimensions","newWidth","newHeight","parseBitmap","cb","_mime","parseBitmap$","_context2","Error","_originalMime","toLowerCase","getMIME","constructor","decoders","throwError","call","t0","create","parse","error","compositeBitmapOverBackground","Jimp","image","_background","composite","getBuffer","AUTO","_rgba","hasAlpha","from","encoders","getBufferAsync"],"sources":["/Users/wolfejam/HEXTRA-3/node_modules/@jimp/core/src/utils/image-bitmap.js"],"sourcesContent":["import FileType from \"file-type\";\n\nimport EXIFParser from \"exif-parser\";\nimport { throwError } from \"@jimp/utils\";\n\nimport * as constants from \"../constants\";\nimport * as MIME from \"./mime\";\nimport promisify from \"./promisify\";\n\nasync function getMIMEFromBuffer(buffer, path) {\n  const fileTypeFromBuffer = await FileType.fromBuffer(buffer);\n\n  if (fileTypeFromBuffer) {\n    // If fileType returns something for buffer, then return the mime given\n    return fileTypeFromBuffer.mime;\n  }\n\n  if (path) {\n    // If a path is supplied, and fileType yields no results, then retry with MIME\n    // Path can be either a file path or a url\n    return MIME.getType(path);\n  }\n\n  return null;\n}\n\n/*\n * Obtains image orientation from EXIF metadata.\n *\n * @param img {Jimp} a Jimp image object\n * @returns {number} a number 1-8 representing EXIF orientation,\n *          in particular 1 if orientation tag is missing\n */\nfunction getExifOrientation(img) {\n  return (img._exif && img._exif.tags && img._exif.tags.Orientation) || 1;\n}\n\n/**\n * Returns a function which translates EXIF-rotated coordinates into\n * non-rotated ones.\n *\n * Transformation reference: http://sylvana.net/jpegcrop/exif_orientation.html.\n *\n * @param img {Jimp} a Jimp image object\n * @returns {function} transformation function for transformBitmap().\n */\nfunction getExifOrientationTransformation(img) {\n  const w = img.getWidth();\n  const h = img.getHeight();\n\n  switch (getExifOrientation(img)) {\n    case 1: // Horizontal (normal)\n      // does not need to be supported here\n      return null;\n\n    case 2: // Mirror horizontal\n      return function (x, y) {\n        return [w - x - 1, y];\n      };\n\n    case 3: // Rotate 180\n      return function (x, y) {\n        return [w - x - 1, h - y - 1];\n      };\n\n    case 4: // Mirror vertical\n      return function (x, y) {\n        return [x, h - y - 1];\n      };\n\n    case 5: // Mirror horizontal and rotate 270 CW\n      return function (x, y) {\n        return [y, x];\n      };\n\n    case 6: // Rotate 90 CW\n      return function (x, y) {\n        return [y, h - x - 1];\n      };\n\n    case 7: // Mirror horizontal and rotate 90 CW\n      return function (x, y) {\n        return [w - y - 1, h - x - 1];\n      };\n\n    case 8: // Rotate 270 CW\n      return function (x, y) {\n        return [w - y - 1, x];\n      };\n\n    default:\n      return null;\n  }\n}\n\n/*\n * Transforms bitmap in place (moves pixels around) according to given\n * transformation function.\n *\n * @param img {Jimp} a Jimp image object, which bitmap is supposed to\n *        be transformed\n * @param width {number} bitmap width after the transformation\n * @param height {number} bitmap height after the transformation\n * @param transformation {function} transformation function which defines pixel\n *        mapping between new and source bitmap. It takes a pair of coordinates\n *        in the target, and returns a respective pair of coordinates in\n *        the source bitmap, i.e. has following form:\n *        `function(new_x, new_y) { return [src_x, src_y] }`.\n */\nfunction transformBitmap(img, width, height, transformation) {\n  // Underscore-prefixed values are related to the source bitmap\n  // Their counterparts with no prefix are related to the target bitmap\n  const _data = img.bitmap.data;\n  const _width = img.bitmap.width;\n\n  const data = Buffer.alloc(_data.length);\n\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height; y++) {\n      const [_x, _y] = transformation(x, y);\n\n      const idx = (width * y + x) << 2;\n      const _idx = (_width * _y + _x) << 2;\n\n      const pixel = _data.readUInt32BE(_idx);\n      data.writeUInt32BE(pixel, idx);\n    }\n  }\n\n  img.bitmap.data = data;\n  img.bitmap.width = width;\n  img.bitmap.height = height;\n}\n\n/*\n * Automagically rotates an image based on its EXIF data (if present).\n * @param img {Jimp} a Jimp image object\n */\nfunction exifRotate(img) {\n  if (getExifOrientation(img) < 2) return;\n\n  const transformation = getExifOrientationTransformation(img);\n  const swapDimensions = getExifOrientation(img) > 4;\n\n  const newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;\n  const newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;\n\n  transformBitmap(img, newWidth, newHeight, transformation);\n}\n\n// parses a bitmap from the constructor to the JIMP bitmap property\nexport async function parseBitmap(data, path, cb) {\n  const mime = await getMIMEFromBuffer(data, path);\n\n  if (typeof mime !== \"string\") {\n    return cb(new Error(\"Could not find MIME for Buffer <\" + path + \">\"));\n  }\n\n  this._originalMime = mime.toLowerCase();\n\n  try {\n    const mime = this.getMIME();\n\n    if (this.constructor.decoders[mime]) {\n      this.bitmap = this.constructor.decoders[mime](data);\n    } else {\n      return throwError.call(this, \"Unsupported MIME type: \" + mime, cb);\n    }\n  } catch (error) {\n    return cb.call(this, error, this);\n  }\n\n  try {\n    this._exif = EXIFParser.create(data).parse();\n    exifRotate(this); // EXIF data\n  } catch (error) {\n    /* meh */\n  }\n\n  cb.call(this, null, this);\n\n  return this;\n}\n\nfunction compositeBitmapOverBackground(Jimp, image) {\n  return new Jimp(\n    image.bitmap.width,\n    image.bitmap.height,\n    image._background\n  ).composite(image, 0, 0).bitmap;\n}\n\n/**\n * Converts the image to a buffer\n * @param {string} mime the mime type of the image buffer to be created\n * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n * @returns {Jimp} this for chaining of methods\n */\nexport function getBuffer(mime, cb) {\n  if (mime === constants.AUTO) {\n    // allow auto MIME detection\n    mime = this.getMIME();\n  }\n\n  if (typeof mime !== \"string\") {\n    return throwError.call(this, \"mime must be a string\", cb);\n  }\n\n  if (typeof cb !== \"function\") {\n    return throwError.call(this, \"cb must be a function\", cb);\n  }\n\n  mime = mime.toLowerCase();\n\n  if (this._rgba && this.constructor.hasAlpha[mime]) {\n    this.bitmap.data = Buffer.from(this.bitmap.data);\n  } else {\n    // when format doesn't support alpha\n    // composite onto a new image so that the background shows through alpha channels\n    this.bitmap.data = compositeBitmapOverBackground(\n      this.constructor,\n      this\n    ).data;\n  }\n\n  if (this.constructor.encoders[mime]) {\n    const buffer = this.constructor.encoders[mime](this);\n    cb.call(this, null, buffer);\n  } else {\n    cb.call(this, \"Unsupported MIME type: \" + mime);\n  }\n\n  return this;\n}\n\nexport function getBufferAsync(mime) {\n  return promisify(getBuffer, this, mime);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}