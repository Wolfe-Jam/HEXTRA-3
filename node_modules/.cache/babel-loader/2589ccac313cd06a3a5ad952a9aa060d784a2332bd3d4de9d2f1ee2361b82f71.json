{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = composite;\nvar _utils = require(\"@jimp/utils\");\nvar constants = _interopRequireWildcard(require(\"../constants\"));\nvar compositeModes = _interopRequireWildcard(require(\"./composite-modes\"));\n\n/**\n * Composites a source image over to this image respecting alpha channels\n * @param {Jimp} src the source Jimp instance\n * @param {number} x the x position to blit the image\n * @param {number} y the y position to blit the image\n * @param {object} options determine what mode to use\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nfunction composite(src, x, y) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var cb = arguments.length > 4 ? arguments[4] : undefined;\n  if (typeof options === \"function\") {\n    cb = options;\n    options = {};\n  }\n  if (!(src instanceof this.constructor)) {\n    return _utils.throwError.call(this, \"The source must be a Jimp image\", cb);\n  }\n  if (typeof x !== \"number\" || typeof y !== \"number\") {\n    return _utils.throwError.call(this, \"x and y must be numbers\", cb);\n  }\n  var _options = options,\n    mode = _options.mode,\n    opacitySource = _options.opacitySource,\n    opacityDest = _options.opacityDest;\n  if (!mode) {\n    mode = constants.BLEND_SOURCE_OVER;\n  }\n  if (typeof opacitySource !== \"number\" || opacitySource < 0 || opacitySource > 1) {\n    opacitySource = 1.0;\n  }\n  if (typeof opacityDest !== \"number\" || opacityDest < 0 || opacityDest > 1) {\n    opacityDest = 1.0;\n  } // eslint-disable-next-line import/namespace\n\n  var blendmode = compositeModes[mode]; // round input\n\n  x = Math.round(x);\n  y = Math.round(y);\n  var baseImage = this;\n  if (opacityDest !== 1.0) {\n    baseImage.opacity(opacityDest);\n  }\n  src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function (sx, sy, idx) {\n    var dstIdx = baseImage.getPixelIndex(x + sx, y + sy, constants.EDGE_CROP);\n    var blended = blendmode({\n      r: this.bitmap.data[idx + 0] / 255,\n      g: this.bitmap.data[idx + 1] / 255,\n      b: this.bitmap.data[idx + 2] / 255,\n      a: this.bitmap.data[idx + 3] / 255\n    }, {\n      r: baseImage.bitmap.data[dstIdx + 0] / 255,\n      g: baseImage.bitmap.data[dstIdx + 1] / 255,\n      b: baseImage.bitmap.data[dstIdx + 2] / 255,\n      a: baseImage.bitmap.data[dstIdx + 3] / 255\n    }, opacitySource);\n    baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(blended.r * 255);\n    baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(blended.g * 255);\n    baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(blended.b * 255);\n    baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(blended.a * 255);\n  });\n  if ((0, _utils.isNodePattern)(cb)) {\n    cb.call(this, null, this);\n  }\n  return this;\n}\nmodule.exports = exports.default;","map":{"version":3,"names":["_utils","require","constants","_interopRequireWildcard","compositeModes","composite","src","x","y","options","arguments","length","undefined","cb","constructor","throwError","call","_options","mode","opacitySource","opacityDest","BLEND_SOURCE_OVER","blendmode","Math","round","baseImage","opacity","scanQuiet","bitmap","width","height","sx","sy","idx","dstIdx","getPixelIndex","EDGE_CROP","blended","r","data","g","b","a","limit255","isNodePattern"],"sources":["/Users/wolfejam/HEXTRA-3/node_modules/@jimp/core/src/composite/index.js"],"sourcesContent":["import { isNodePattern, throwError } from \"@jimp/utils\";\nimport * as constants from \"../constants\";\n\nimport * as compositeModes from \"./composite-modes\";\n\n/**\n * Composites a source image over to this image respecting alpha channels\n * @param {Jimp} src the source Jimp instance\n * @param {number} x the x position to blit the image\n * @param {number} y the y position to blit the image\n * @param {object} options determine what mode to use\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport default function composite(src, x, y, options = {}, cb) {\n  if (typeof options === \"function\") {\n    cb = options;\n    options = {};\n  }\n\n  if (!(src instanceof this.constructor)) {\n    return throwError.call(this, \"The source must be a Jimp image\", cb);\n  }\n\n  if (typeof x !== \"number\" || typeof y !== \"number\") {\n    return throwError.call(this, \"x and y must be numbers\", cb);\n  }\n\n  let { mode, opacitySource, opacityDest } = options;\n\n  if (!mode) {\n    mode = constants.BLEND_SOURCE_OVER;\n  }\n\n  if (\n    typeof opacitySource !== \"number\" ||\n    opacitySource < 0 ||\n    opacitySource > 1\n  ) {\n    opacitySource = 1.0;\n  }\n\n  if (typeof opacityDest !== \"number\" || opacityDest < 0 || opacityDest > 1) {\n    opacityDest = 1.0;\n  }\n\n  // eslint-disable-next-line import/namespace\n  const blendmode = compositeModes[mode];\n\n  // round input\n  x = Math.round(x);\n  y = Math.round(y);\n\n  const baseImage = this;\n\n  if (opacityDest !== 1.0) {\n    baseImage.opacity(opacityDest);\n  }\n\n  src.scanQuiet(\n    0,\n    0,\n    src.bitmap.width,\n    src.bitmap.height,\n    function (sx, sy, idx) {\n      const dstIdx = baseImage.getPixelIndex(\n        x + sx,\n        y + sy,\n        constants.EDGE_CROP\n      );\n      const blended = blendmode(\n        {\n          r: this.bitmap.data[idx + 0] / 255,\n          g: this.bitmap.data[idx + 1] / 255,\n          b: this.bitmap.data[idx + 2] / 255,\n          a: this.bitmap.data[idx + 3] / 255,\n        },\n        {\n          r: baseImage.bitmap.data[dstIdx + 0] / 255,\n          g: baseImage.bitmap.data[dstIdx + 1] / 255,\n          b: baseImage.bitmap.data[dstIdx + 2] / 255,\n          a: baseImage.bitmap.data[dstIdx + 3] / 255,\n        },\n        opacitySource\n      );\n\n      baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(\n        blended.r * 255\n      );\n      baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(\n        blended.g * 255\n      );\n      baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(\n        blended.b * 255\n      );\n      baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(\n        blended.a * 255\n      );\n    }\n  );\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, this);\n  }\n\n  return this;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}