{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = pluginCrop;\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _utils = require(\"@jimp/utils\");\n\n/* eslint-disable no-labels */\nfunction pluginCrop(event) {\n  /**\n   * Crops the image at a given point to a give size\n   * @param {number} x the x coordinate to crop form\n   * @param {number} y the y coordinate to crop form\n   * @param w the width of the crop region\n   * @param h the height of the crop region\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  event(\"crop\", function (x, y, w, h, cb) {\n    if (typeof x !== \"number\" || typeof y !== \"number\") return _utils.throwError.call(this, \"x and y must be numbers\", cb);\n    if (typeof w !== \"number\" || typeof h !== \"number\") return _utils.throwError.call(this, \"w and h must be numbers\", cb); // round input\n\n    x = Math.round(x);\n    y = Math.round(y);\n    w = Math.round(w);\n    h = Math.round(h);\n    if (x === 0 && w === this.bitmap.width) {\n      // shortcut\n      var start = w * y + x << 2;\n      var end = start + (h * w << 2);\n      this.bitmap.data = this.bitmap.data.slice(start, end);\n    } else {\n      var bitmap = Buffer.allocUnsafe(w * h * 4);\n      var offset = 0;\n      this.scanQuiet(x, y, w, h, function (x, y, idx) {\n        var data = this.bitmap.data.readUInt32BE(idx, true);\n        bitmap.writeUInt32BE(data, offset, true);\n        offset += 4;\n      });\n      this.bitmap.data = bitmap;\n    }\n    this.bitmap.width = w;\n    this.bitmap.height = h;\n    if ((0, _utils.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  });\n  return {\n    \"class\": {\n      /**\n       * Autocrop same color borders from this image\n       * @param {number} tolerance (optional): a percent value of tolerance for pixels color difference (default: 0.0002%)\n       * @param {boolean} cropOnlyFrames (optional): flag to crop only real frames: all 4 sides of the image must have some border (default: true)\n       * @param {function(Error, Jimp)} cb (optional): a callback for when complete (default: no callback)\n       * @returns {Jimp} this for chaining of methods\n       */\n      autocrop: function autocrop() {\n        var w = this.bitmap.width;\n        var h = this.bitmap.height;\n        var minPixelsPerSide = 1; // to avoid cropping completely the image, resulting in an invalid 0 sized image\n\n        var cb; // callback\n\n        var leaveBorder = 0; // Amount of pixels in border to leave\n\n        var tolerance = 0.0002; // percent of color difference tolerance (default value)\n\n        var cropOnlyFrames = true; // flag to force cropping only if the image has a real \"frame\"\n        // i.e. all 4 sides have some border (default value)\n\n        var cropSymmetric = false; // flag to force cropping top be symmetric.\n        // i.e. north and south / east and west are cropped by the same value\n\n        var ignoreSides = {\n          north: false,\n          south: false,\n          east: false,\n          west: false\n        }; // parse arguments\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        for (var a = 0, len = args.length; a < len; a++) {\n          if (typeof args[a] === \"number\") {\n            // tolerance value passed\n            tolerance = args[a];\n          }\n          if (typeof args[a] === \"boolean\") {\n            // cropOnlyFrames value passed\n            cropOnlyFrames = args[a];\n          }\n          if (typeof args[a] === \"function\") {\n            // callback value passed\n            cb = args[a];\n          }\n          if ((0, _typeof2[\"default\"])(args[a]) === \"object\") {\n            // config object passed\n            var config = args[a];\n            if (typeof config.tolerance !== \"undefined\") {\n              tolerance = config.tolerance;\n            }\n            if (typeof config.cropOnlyFrames !== \"undefined\") {\n              cropOnlyFrames = config.cropOnlyFrames;\n            }\n            if (typeof config.cropSymmetric !== \"undefined\") {\n              cropSymmetric = config.cropSymmetric;\n            }\n            if (typeof config.leaveBorder !== \"undefined\") {\n              leaveBorder = config.leaveBorder;\n            }\n            if (typeof config.ignoreSides !== \"undefined\") {\n              ignoreSides = config.ignoreSides;\n            }\n          }\n        }\n        /**\n         * All borders must be of the same color as the top left pixel, to be cropped.\n         * It should be possible to crop borders each with a different color,\n         * but since there are many ways for corners to intersect, it would\n         * introduce unnecessary complexity to the algorithm.\n         */\n        // scan each side for same color borders\n\n        var colorTarget = this.getPixelColor(0, 0); // top left pixel color is the target color\n\n        var rgba1 = this.constructor.intToRGBA(colorTarget); // for north and east sides\n\n        var northPixelsToCrop = 0;\n        var eastPixelsToCrop = 0;\n        var southPixelsToCrop = 0;\n        var westPixelsToCrop = 0; // north side (scan rows from north to south)\n\n        colorTarget = this.getPixelColor(0, 0);\n        if (!ignoreSides.north) {\n          north: for (var y = 0; y < h - minPixelsPerSide; y++) {\n            for (var x = 0; x < w; x++) {\n              var colorXY = this.getPixelColor(x, y);\n              var rgba2 = this.constructor.intToRGBA(colorXY);\n              if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break north;\n              }\n            } // this row contains all pixels with the same color: increment this side pixels to crop\n\n            northPixelsToCrop++;\n          }\n        } // east side (scan columns from east to west)\n\n        colorTarget = this.getPixelColor(w, 0);\n        if (!ignoreSides.east) {\n          east: for (var _x = 0; _x < w - minPixelsPerSide; _x++) {\n            for (var _y = 0 + northPixelsToCrop; _y < h; _y++) {\n              var _colorXY = this.getPixelColor(_x, _y);\n              var _rgba = this.constructor.intToRGBA(_colorXY);\n              if (this.constructor.colorDiff(rgba1, _rgba) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break east;\n              }\n            } // this column contains all pixels with the same color: increment this side pixels to crop\n\n            eastPixelsToCrop++;\n          }\n        } // south side (scan rows from south to north)\n\n        colorTarget = this.getPixelColor(0, h);\n        if (!ignoreSides.south) {\n          south: for (var _y2 = h - 1; _y2 >= northPixelsToCrop + minPixelsPerSide; _y2--) {\n            for (var _x2 = w - eastPixelsToCrop - 1; _x2 >= 0; _x2--) {\n              var _colorXY2 = this.getPixelColor(_x2, _y2);\n              var _rgba2 = this.constructor.intToRGBA(_colorXY2);\n              if (this.constructor.colorDiff(rgba1, _rgba2) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break south;\n              }\n            } // this row contains all pixels with the same color: increment this side pixels to crop\n\n            southPixelsToCrop++;\n          }\n        } // west side (scan columns from west to east)\n\n        colorTarget = this.getPixelColor(w, h);\n        if (!ignoreSides.west) {\n          west: for (var _x3 = w - 1; _x3 >= 0 + eastPixelsToCrop + minPixelsPerSide; _x3--) {\n            for (var _y3 = h - 1; _y3 >= 0 + northPixelsToCrop; _y3--) {\n              var _colorXY3 = this.getPixelColor(_x3, _y3);\n              var _rgba3 = this.constructor.intToRGBA(_colorXY3);\n              if (this.constructor.colorDiff(rgba1, _rgba3) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break west;\n              }\n            } // this column contains all pixels with the same color: increment this side pixels to crop\n\n            westPixelsToCrop++;\n          }\n        } // decide if a crop is needed\n\n        var doCrop = false; // apply leaveBorder\n\n        westPixelsToCrop -= leaveBorder;\n        eastPixelsToCrop -= leaveBorder;\n        northPixelsToCrop -= leaveBorder;\n        southPixelsToCrop -= leaveBorder;\n        if (cropSymmetric) {\n          var horizontal = Math.min(eastPixelsToCrop, westPixelsToCrop);\n          var vertical = Math.min(northPixelsToCrop, southPixelsToCrop);\n          westPixelsToCrop = horizontal;\n          eastPixelsToCrop = horizontal;\n          northPixelsToCrop = vertical;\n          southPixelsToCrop = vertical;\n        } // make sure that crops are >= 0\n\n        westPixelsToCrop = westPixelsToCrop >= 0 ? westPixelsToCrop : 0;\n        eastPixelsToCrop = eastPixelsToCrop >= 0 ? eastPixelsToCrop : 0;\n        northPixelsToCrop = northPixelsToCrop >= 0 ? northPixelsToCrop : 0;\n        southPixelsToCrop = southPixelsToCrop >= 0 ? southPixelsToCrop : 0; // safety checks\n\n        var widthOfRemainingPixels = w - (westPixelsToCrop + eastPixelsToCrop);\n        var heightOfRemainingPixels = h - (southPixelsToCrop + northPixelsToCrop);\n        if (cropOnlyFrames) {\n          // crop image if all sides should be cropped\n          doCrop = eastPixelsToCrop !== 0 && northPixelsToCrop !== 0 && westPixelsToCrop !== 0 && southPixelsToCrop !== 0;\n        } else {\n          // crop image if at least one side should be cropped\n          doCrop = eastPixelsToCrop !== 0 || northPixelsToCrop !== 0 || westPixelsToCrop !== 0 || southPixelsToCrop !== 0;\n        }\n        if (doCrop) {\n          // do the real crop\n          this.crop(eastPixelsToCrop, northPixelsToCrop, widthOfRemainingPixels, heightOfRemainingPixels);\n        }\n        if ((0, _utils.isNodePattern)(cb)) {\n          cb.call(this, null, this);\n        }\n        return this;\n      }\n    }\n  };\n}\nmodule.exports = exports.default;","map":{"version":3,"names":["_utils","require","pluginCrop","event","x","y","w","h","cb","throwError","call","Math","round","bitmap","width","start","end","data","slice","Buffer","allocUnsafe","offset","scanQuiet","idx","readUInt32BE","writeUInt32BE","height","isNodePattern","autocrop","minPixelsPerSide","leaveBorder","tolerance","cropOnlyFrames","cropSymmetric","ignoreSides","north","south","east","west","_len","arguments","length","args","Array","_key","a","len","_typeof2","config","colorTarget","getPixelColor","rgba1","constructor","intToRGBA","northPixelsToCrop","eastPixelsToCrop","southPixelsToCrop","westPixelsToCrop","colorXY","rgba2","colorDiff","_x","_y","_colorXY","_rgba","_y2","_x2","_colorXY2","_rgba2","_x3","_y3","_colorXY3","_rgba3","doCrop","horizontal","min","vertical","widthOfRemainingPixels","heightOfRemainingPixels","crop"],"sources":["/Users/wolfejam/HEXTRA-3/node_modules/@jimp/plugin-crop/src/index.js"],"sourcesContent":["/* eslint-disable no-labels */\n\nimport { throwError, isNodePattern } from \"@jimp/utils\";\n\nexport default function pluginCrop(event) {\n  /**\n   * Crops the image at a given point to a give size\n   * @param {number} x the x coordinate to crop form\n   * @param {number} y the y coordinate to crop form\n   * @param w the width of the crop region\n   * @param h the height of the crop region\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  event(\"crop\", function (x, y, w, h, cb) {\n    if (typeof x !== \"number\" || typeof y !== \"number\")\n      return throwError.call(this, \"x and y must be numbers\", cb);\n    if (typeof w !== \"number\" || typeof h !== \"number\")\n      return throwError.call(this, \"w and h must be numbers\", cb);\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n    w = Math.round(w);\n    h = Math.round(h);\n\n    if (x === 0 && w === this.bitmap.width) {\n      // shortcut\n      const start = (w * y + x) << 2;\n      const end = start + ((h * w) << 2);\n\n      this.bitmap.data = this.bitmap.data.slice(start, end);\n    } else {\n      const bitmap = Buffer.allocUnsafe(w * h * 4);\n      let offset = 0;\n\n      this.scanQuiet(x, y, w, h, function (x, y, idx) {\n        const data = this.bitmap.data.readUInt32BE(idx, true);\n        bitmap.writeUInt32BE(data, offset, true);\n        offset += 4;\n      });\n\n      this.bitmap.data = bitmap;\n    }\n\n    this.bitmap.width = w;\n    this.bitmap.height = h;\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  });\n\n  return {\n    class: {\n      /**\n       * Autocrop same color borders from this image\n       * @param {number} tolerance (optional): a percent value of tolerance for pixels color difference (default: 0.0002%)\n       * @param {boolean} cropOnlyFrames (optional): flag to crop only real frames: all 4 sides of the image must have some border (default: true)\n       * @param {function(Error, Jimp)} cb (optional): a callback for when complete (default: no callback)\n       * @returns {Jimp} this for chaining of methods\n       */\n      autocrop(...args) {\n        const w = this.bitmap.width;\n        const h = this.bitmap.height;\n        const minPixelsPerSide = 1; // to avoid cropping completely the image, resulting in an invalid 0 sized image\n\n        let cb; // callback\n        let leaveBorder = 0; // Amount of pixels in border to leave\n        let tolerance = 0.0002; // percent of color difference tolerance (default value)\n        let cropOnlyFrames = true; // flag to force cropping only if the image has a real \"frame\"\n        // i.e. all 4 sides have some border (default value)\n        let cropSymmetric = false; // flag to force cropping top be symmetric.\n        // i.e. north and south / east and west are cropped by the same value\n        let ignoreSides = {\n          north: false,\n          south: false,\n          east: false,\n          west: false,\n        };\n\n        // parse arguments\n        for (let a = 0, len = args.length; a < len; a++) {\n          if (typeof args[a] === \"number\") {\n            // tolerance value passed\n            tolerance = args[a];\n          }\n\n          if (typeof args[a] === \"boolean\") {\n            // cropOnlyFrames value passed\n            cropOnlyFrames = args[a];\n          }\n\n          if (typeof args[a] === \"function\") {\n            // callback value passed\n            cb = args[a];\n          }\n\n          if (typeof args[a] === \"object\") {\n            // config object passed\n            const config = args[a];\n\n            if (typeof config.tolerance !== \"undefined\") {\n              ({ tolerance } = config);\n            }\n\n            if (typeof config.cropOnlyFrames !== \"undefined\") {\n              ({ cropOnlyFrames } = config);\n            }\n\n            if (typeof config.cropSymmetric !== \"undefined\") {\n              ({ cropSymmetric } = config);\n            }\n\n            if (typeof config.leaveBorder !== \"undefined\") {\n              ({ leaveBorder } = config);\n            }\n\n            if (typeof config.ignoreSides !== \"undefined\") {\n              ({ ignoreSides } = config);\n            }\n          }\n        }\n\n        /**\n         * All borders must be of the same color as the top left pixel, to be cropped.\n         * It should be possible to crop borders each with a different color,\n         * but since there are many ways for corners to intersect, it would\n         * introduce unnecessary complexity to the algorithm.\n         */\n\n        // scan each side for same color borders\n        let colorTarget = this.getPixelColor(0, 0); // top left pixel color is the target color\n        const rgba1 = this.constructor.intToRGBA(colorTarget);\n\n        // for north and east sides\n        let northPixelsToCrop = 0;\n        let eastPixelsToCrop = 0;\n        let southPixelsToCrop = 0;\n        let westPixelsToCrop = 0;\n\n        // north side (scan rows from north to south)\n        colorTarget = this.getPixelColor(0, 0);\n        if (!ignoreSides.north) {\n          north: for (let y = 0; y < h - minPixelsPerSide; y++) {\n            for (let x = 0; x < w; x++) {\n              const colorXY = this.getPixelColor(x, y);\n              const rgba2 = this.constructor.intToRGBA(colorXY);\n\n              if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break north;\n              }\n            }\n\n            // this row contains all pixels with the same color: increment this side pixels to crop\n            northPixelsToCrop++;\n          }\n        }\n\n        // east side (scan columns from east to west)\n        colorTarget = this.getPixelColor(w, 0);\n        if (!ignoreSides.east) {\n          east: for (let x = 0; x < w - minPixelsPerSide; x++) {\n            for (let y = 0 + northPixelsToCrop; y < h; y++) {\n              const colorXY = this.getPixelColor(x, y);\n              const rgba2 = this.constructor.intToRGBA(colorXY);\n\n              if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break east;\n              }\n            }\n\n            // this column contains all pixels with the same color: increment this side pixels to crop\n            eastPixelsToCrop++;\n          }\n        }\n\n        // south side (scan rows from south to north)\n        colorTarget = this.getPixelColor(0, h);\n\n        if (!ignoreSides.south) {\n          south: for (\n            let y = h - 1;\n            y >= northPixelsToCrop + minPixelsPerSide;\n            y--\n          ) {\n            for (let x = w - eastPixelsToCrop - 1; x >= 0; x--) {\n              const colorXY = this.getPixelColor(x, y);\n              const rgba2 = this.constructor.intToRGBA(colorXY);\n\n              if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break south;\n              }\n            }\n\n            // this row contains all pixels with the same color: increment this side pixels to crop\n            southPixelsToCrop++;\n          }\n        }\n\n        // west side (scan columns from west to east)\n        colorTarget = this.getPixelColor(w, h);\n        if (!ignoreSides.west) {\n          west: for (\n            let x = w - 1;\n            x >= 0 + eastPixelsToCrop + minPixelsPerSide;\n            x--\n          ) {\n            for (let y = h - 1; y >= 0 + northPixelsToCrop; y--) {\n              const colorXY = this.getPixelColor(x, y);\n              const rgba2 = this.constructor.intToRGBA(colorXY);\n\n              if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break west;\n              }\n            }\n\n            // this column contains all pixels with the same color: increment this side pixels to crop\n            westPixelsToCrop++;\n          }\n        }\n\n        // decide if a crop is needed\n        let doCrop = false;\n\n        // apply leaveBorder\n        westPixelsToCrop -= leaveBorder;\n        eastPixelsToCrop -= leaveBorder;\n        northPixelsToCrop -= leaveBorder;\n        southPixelsToCrop -= leaveBorder;\n\n        if (cropSymmetric) {\n          const horizontal = Math.min(eastPixelsToCrop, westPixelsToCrop);\n          const vertical = Math.min(northPixelsToCrop, southPixelsToCrop);\n          westPixelsToCrop = horizontal;\n          eastPixelsToCrop = horizontal;\n          northPixelsToCrop = vertical;\n          southPixelsToCrop = vertical;\n        }\n\n        // make sure that crops are >= 0\n        westPixelsToCrop = westPixelsToCrop >= 0 ? westPixelsToCrop : 0;\n        eastPixelsToCrop = eastPixelsToCrop >= 0 ? eastPixelsToCrop : 0;\n        northPixelsToCrop = northPixelsToCrop >= 0 ? northPixelsToCrop : 0;\n        southPixelsToCrop = southPixelsToCrop >= 0 ? southPixelsToCrop : 0;\n\n        // safety checks\n        const widthOfRemainingPixels =\n          w - (westPixelsToCrop + eastPixelsToCrop);\n        const heightOfRemainingPixels =\n          h - (southPixelsToCrop + northPixelsToCrop);\n\n        if (cropOnlyFrames) {\n          // crop image if all sides should be cropped\n          doCrop =\n            eastPixelsToCrop !== 0 &&\n            northPixelsToCrop !== 0 &&\n            westPixelsToCrop !== 0 &&\n            southPixelsToCrop !== 0;\n        } else {\n          // crop image if at least one side should be cropped\n          doCrop =\n            eastPixelsToCrop !== 0 ||\n            northPixelsToCrop !== 0 ||\n            westPixelsToCrop !== 0 ||\n            southPixelsToCrop !== 0;\n        }\n\n        if (doCrop) {\n          // do the real crop\n          this.crop(\n            eastPixelsToCrop,\n            northPixelsToCrop,\n            widthOfRemainingPixels,\n            heightOfRemainingPixels\n          );\n        }\n\n        if (isNodePattern(cb)) {\n          cb.call(this, null, this);\n        }\n\n        return this;\n      },\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}