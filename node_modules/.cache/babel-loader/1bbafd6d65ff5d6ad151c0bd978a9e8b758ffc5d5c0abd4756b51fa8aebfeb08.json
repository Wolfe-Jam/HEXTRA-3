{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar _utils = require(\"@jimp/utils\");\n\n/**\n * Masks a source image on to this image using average pixel colour. A completely black pixel on the mask will turn a pixel in the image completely transparent.\n * @param {Jimp} src the source Jimp instance\n * @param {number} x the horizontal position to blit the image\n * @param {number} y the vertical position to blit the image\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nvar _default = function _default() {\n  return {\n    mask: function mask(src) {\n      var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var cb = arguments.length > 3 ? arguments[3] : undefined;\n      if (!(src instanceof this.constructor)) {\n        return _utils.throwError.call(this, \"The source must be a Jimp image\", cb);\n      }\n      if (typeof x !== \"number\" || typeof y !== \"number\") {\n        return _utils.throwError.call(this, \"x and y must be numbers\", cb);\n      } // round input\n\n      x = Math.round(x);\n      y = Math.round(y);\n      var w = this.bitmap.width;\n      var h = this.bitmap.height;\n      var baseImage = this;\n      src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function (sx, sy, idx) {\n        var destX = x + sx;\n        var destY = y + sy;\n        if (destX >= 0 && destY >= 0 && destX < w && destY < h) {\n          var dstIdx = baseImage.getPixelIndex(destX, destY);\n          var data = this.bitmap.data;\n          var avg = (data[idx + 0] + data[idx + 1] + data[idx + 2]) / 3;\n          baseImage.bitmap.data[dstIdx + 3] *= avg / 255;\n        }\n      });\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    }\n  };\n};\nexports[\"default\"] = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["_utils","require","_default","mask","src","x","arguments","length","undefined","y","cb","constructor","throwError","call","Math","round","w","bitmap","width","h","height","baseImage","scanQuiet","sx","sy","idx","destX","destY","dstIdx","getPixelIndex","data","avg","isNodePattern"],"sources":["/Users/wolfejam/HEXTRA-3/node_modules/@jimp/plugin-mask/src/index.js"],"sourcesContent":["import { isNodePattern, throwError } from \"@jimp/utils\";\n\n/**\n * Masks a source image on to this image using average pixel colour. A completely black pixel on the mask will turn a pixel in the image completely transparent.\n * @param {Jimp} src the source Jimp instance\n * @param {number} x the horizontal position to blit the image\n * @param {number} y the vertical position to blit the image\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport default () => ({\n  mask(src, x = 0, y = 0, cb) {\n    if (!(src instanceof this.constructor)) {\n      return throwError.call(this, \"The source must be a Jimp image\", cb);\n    }\n\n    if (typeof x !== \"number\" || typeof y !== \"number\") {\n      return throwError.call(this, \"x and y must be numbers\", cb);\n    }\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n\n    const w = this.bitmap.width;\n    const h = this.bitmap.height;\n    const baseImage = this;\n\n    src.scanQuiet(\n      0,\n      0,\n      src.bitmap.width,\n      src.bitmap.height,\n      function (sx, sy, idx) {\n        const destX = x + sx;\n        const destY = y + sy;\n\n        if (destX >= 0 && destY >= 0 && destX < w && destY < h) {\n          const dstIdx = baseImage.getPixelIndex(destX, destY);\n          const { data } = this.bitmap;\n          const avg = (data[idx + 0] + data[idx + 1] + data[idx + 2]) / 3;\n\n          baseImage.bitmap.data[dstIdx + 3] *= avg / 255;\n        }\n      }\n    );\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n});\n"],"mappings":";;;;;;AAAA,IAAAA,MAAA,GAAAC,OAAA;;AAEA;;;;;;;;eAQe,SAAAC,SAAA;EAAA,OAAO;IACpBC,IADoB,WAAAA,KACfC,GADe,EACQ;MAAA,IAAlBC,CAAkB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAd,CAAc;MAAA,IAAXG,CAAW,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAP,CAAO;MAAA,IAAJI,EAAI,GAAAJ,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;MAC1B,IAAI,EAAEJ,GAAG,YAAY,KAAKO,WAAtB,CAAJ,EAAwC;QACtC,OAAOX,MAAA,CAAAY,UAAA,CAAWC,IAAX,CAAgB,IAAhB,EAAsB,iCAAtB,EAAyDH,EAAzD,CAAP;MACD;MAED,IAAI,OAAOL,CAAP,KAAa,QAAb,IAAyB,OAAOI,CAAP,KAAa,QAA1C,EAAoD;QAClD,OAAOT,MAAA,CAAAY,UAAA,CAAWC,IAAX,CAAgB,IAAhB,EAAsB,yBAAtB,EAAiDH,EAAjD,CAAP;MACD,CAPyB,CAS1B;;MACAL,CAAC,GAAGS,IAAI,CAACC,KAAL,CAAWV,CAAX,CAAJ;MACAI,CAAC,GAAGK,IAAI,CAACC,KAAL,CAAWN,CAAX,CAAJ;MAEA,IAAMO,CAAC,GAAG,KAAKC,MAAL,CAAYC,KAAtB;MACA,IAAMC,CAAC,GAAG,KAAKF,MAAL,CAAYG,MAAtB;MACA,IAAMC,SAAS,GAAG,IAAlB;MAEAjB,GAAG,CAACkB,SAAJ,CACE,CADF,EAEE,CAFF,EAGElB,GAAG,CAACa,MAAJ,CAAWC,KAHb,EAIEd,GAAG,CAACa,MAAJ,CAAWG,MAJb,EAKE,UAAUG,EAAV,EAAcC,EAAd,EAAkBC,GAAlB,EAAuB;QACrB,IAAMC,KAAK,GAAGrB,CAAC,GAAGkB,EAAlB;QACA,IAAMI,KAAK,GAAGlB,CAAC,GAAGe,EAAlB;QAEA,IAAIE,KAAK,IAAI,CAAT,IAAcC,KAAK,IAAI,CAAvB,IAA4BD,KAAK,GAAGV,CAApC,IAAyCW,KAAK,GAAGR,CAArD,EAAwD;UACtD,IAAMS,MAAM,GAAGP,SAAS,CAACQ,aAAV,CAAwBH,KAAxB,EAA+BC,KAA/B,CAAf;UADsD,IAE9CG,IAF8C,GAErC,KAAKb,MAFgC,CAE9Ca,IAF8C;UAGtD,IAAMC,GAAG,GAAG,CAACD,IAAI,CAACL,GAAG,GAAG,CAAP,CAAJ,GAAgBK,IAAI,CAACL,GAAG,GAAG,CAAP,CAApB,GAAgCK,IAAI,CAACL,GAAG,GAAG,CAAP,CAArC,IAAkD,CAA9D;UAEAJ,SAAS,CAACJ,MAAV,CAAiBa,IAAjB,CAAsBF,MAAM,GAAG,CAA/B,KAAqCG,GAAG,GAAG,GAA3C;QACD;MACF,CAhBH;MAmBA,IAAI,IAAA/B,MAAA,CAAAgC,aAAA,EAActB,EAAd,CAAJ,EAAuB;QACrBA,EAAE,CAACG,IAAH,CAAQ,IAAR,EAAc,IAAd,EAAoB,IAApB;MACD;MAED,OAAO,IAAP;IACD;EA1CmB,CAAP;AAAA,C","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}