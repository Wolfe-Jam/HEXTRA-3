{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addConstants = addConstants;\nexports.addJimpMethods = addJimpMethods;\nexports.jimpEvMethod = jimpEvMethod;\nexports.jimpEvChange = jimpEvChange;\nObject.defineProperty(exports, \"addType\", {\n  enumerable: true,\n  get: function get() {\n    return MIME.addType;\n  }\n});\nexports[\"default\"] = void 0;\nvar _construct2 = _interopRequireDefault(require(\"@babel/runtime/helpers/construct\"));\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _events = _interopRequireDefault(require(\"events\"));\nvar _utils = require(\"@jimp/utils\");\nvar _anyBase = _interopRequireDefault(require(\"any-base\"));\nvar _mkdirp = _interopRequireDefault(require(\"mkdirp\"));\nvar _pixelmatch = _interopRequireDefault(require(\"pixelmatch\"));\nvar _tinycolor = _interopRequireDefault(require(\"tinycolor2\"));\nvar _phash = _interopRequireDefault(require(\"./modules/phash\"));\nvar _request = _interopRequireDefault(require(\"./request\"));\nvar _composite = _interopRequireDefault(require(\"./composite\"));\nvar _promisify = _interopRequireDefault(require(\"./utils/promisify\"));\nvar MIME = _interopRequireWildcard(require(\"./utils/mime\"));\nvar _imageBitmap = require(\"./utils/image-bitmap\");\nvar constants = _interopRequireWildcard(require(\"./constants\"));\nvar alphabet = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_\"; // an array storing the maximum string length of hashes at various bases\n// 0 and 1 do not exist as possible hash lengths\n\nvar maxHashLength = [NaN, NaN];\nfor (var i = 2; i < 65; i++) {\n  var maxHash = (0, _anyBase[\"default\"])(_anyBase[\"default\"].BIN, alphabet.slice(0, i))(new Array(64 + 1).join(\"1\"));\n  maxHashLength.push(maxHash.length);\n} // no operation\n\nfunction noop() {} // error checking methods\n\nfunction isArrayBuffer(test) {\n  return Object.prototype.toString.call(test).toLowerCase().indexOf(\"arraybuffer\") > -1;\n} // Prepare a Buffer object from the arrayBuffer. Necessary in the browser > node conversion,\n// But this function is not useful when running in node directly\n\nfunction bufferFromArrayBuffer(arrayBuffer) {\n  var buffer = Buffer.alloc(arrayBuffer.byteLength);\n  var view = new Uint8Array(arrayBuffer);\n  for (var _i = 0; _i < buffer.length; ++_i) {\n    buffer[_i] = view[_i];\n  }\n  return buffer;\n}\nfunction loadFromURL(options, cb) {\n  (0, _request[\"default\"])(options, function (err, response, data) {\n    if (err) {\n      return cb(err);\n    }\n    if (\"headers\" in response && \"location\" in response.headers) {\n      options.url = response.headers.location;\n      return loadFromURL(options, cb);\n    }\n    if ((0, _typeof2[\"default\"])(data) === \"object\" && Buffer.isBuffer(data)) {\n      return cb(null, data);\n    }\n    var msg = \"Could not load Buffer from <\" + options.url + \"> \" + \"(HTTP: \" + response.statusCode + \")\";\n    return new Error(msg);\n  });\n}\nfunction loadBufferFromPath(src, cb) {\n  if (_fs[\"default\"] && typeof _fs[\"default\"].readFile === \"function\" && !src.match(/^(http|ftp)s?:\\/\\/./)) {\n    _fs[\"default\"].readFile(src, cb);\n  } else {\n    loadFromURL({\n      url: src\n    }, cb);\n  }\n}\nfunction isRawRGBAData(obj) {\n  return obj && (0, _typeof2[\"default\"])(obj) === \"object\" && typeof obj.width === \"number\" && typeof obj.height === \"number\" && (Buffer.isBuffer(obj.data) || obj.data instanceof Uint8Array || typeof Uint8ClampedArray === \"function\" && obj.data instanceof Uint8ClampedArray) && (obj.data.length === obj.width * obj.height * 4 || obj.data.length === obj.width * obj.height * 3);\n}\nfunction makeRGBABufferFromRGB(buffer) {\n  if (buffer.length % 3 !== 0) {\n    throw new Error(\"Buffer length is incorrect\");\n  }\n  var rgbaBuffer = Buffer.allocUnsafe(buffer.length / 3 * 4);\n  var j = 0;\n  for (var _i2 = 0; _i2 < buffer.length; _i2++) {\n    rgbaBuffer[j] = buffer[_i2];\n    if ((_i2 + 1) % 3 === 0) {\n      rgbaBuffer[++j] = 255;\n    }\n    j++;\n  }\n  return rgbaBuffer;\n}\nvar emptyBitmap = {\n  data: null,\n  width: null,\n  height: null\n};\n/**\n * Jimp constructor (from a file)\n * @param path a path to the image\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from a url with options)\n * @param options { url, otherOptions}\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from another Jimp image or raw image data)\n * @param image a Jimp image to clone\n * @param {function(Error, Jimp)} cb a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from a Buffer)\n * @param data a Buffer containing the image data\n * @param {function(Error, Jimp)} cb a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (to generate a new image)\n * @param w the width of the image\n * @param h the height of the image\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (to generate a new image)\n * @param w the width of the image\n * @param h the height of the image\n * @param background color to fill the image with\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\nvar Jimp = /*#__PURE__*/\nfunction (_EventEmitter) {\n  (0, _inherits2[\"default\"])(Jimp, _EventEmitter);\n\n  // An object representing a bitmap in memory, comprising:\n  //  - data: a buffer of the bitmap data\n  //  - width: the width of the image in pixels\n  //  - height: the height of the image in pixels\n  // Default colour to use for new pixels\n  // Default MIME is PNG\n  // Exif data for the image\n  // Whether Transparency supporting formats will be exported as RGB or RGBA\n  function Jimp() {\n    var _this;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    (0, _classCallCheck2[\"default\"])(this, Jimp);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(Jimp).call(this));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"bitmap\", emptyBitmap);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_background\", 0x00000000);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_originalMime\", Jimp.MIME_PNG);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_exif\", null);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_rgba\", true);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"writeAsync\", function (path) {\n      return (0, _promisify[\"default\"])(_this.write, (0, _assertThisInitialized2[\"default\"])(_this), path);\n    });\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"getBase64Async\", function (mime) {\n      return (0, _promisify[\"default\"])(_this.getBase64, (0, _assertThisInitialized2[\"default\"])(_this), mime);\n    });\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"getBuffer\", _imageBitmap.getBuffer);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"getBufferAsync\", _imageBitmap.getBufferAsync);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"getPixelColour\", _this.getPixelColor);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"setPixelColour\", _this.setPixelColor);\n    var jimpInstance = (0, _assertThisInitialized2[\"default\"])(_this);\n    var cb = noop;\n    if (isArrayBuffer(args[0])) {\n      args[0] = bufferFromArrayBuffer(args[0]);\n    }\n    function finish() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      var err = args[0];\n      var evData = err || {};\n      evData.methodName = \"constructor\";\n      setTimeout(function () {\n        var _cb;\n\n        // run on next tick.\n        if (err && cb === noop) {\n          jimpInstance.emitError(\"constructor\", err);\n        } else if (!err) {\n          jimpInstance.emitMulti(\"constructor\", \"initialized\");\n        }\n        (_cb = cb).call.apply(_cb, [jimpInstance].concat(args));\n      }, 1);\n    }\n    if (typeof args[0] === \"number\" && typeof args[1] === \"number\" || parseInt(args[0], 10) && parseInt(args[1], 10)) {\n      // create a new image\n      var w = parseInt(args[0], 10);\n      var h = parseInt(args[1], 10);\n      cb = args[2]; // with a hex color\n\n      if (typeof args[2] === \"number\") {\n        _this._background = args[2];\n        cb = args[3];\n      } // with a css color\n\n      if (typeof args[2] === \"string\") {\n        _this._background = Jimp.cssColorToHex(args[2]);\n        cb = args[3];\n      }\n      if (typeof cb === \"undefined\") {\n        cb = noop;\n      }\n      if (typeof cb !== \"function\") {\n        return (0, _possibleConstructorReturn2[\"default\"])(_this, _utils.throwError.call((0, _assertThisInitialized2[\"default\"])(_this), \"cb must be a function\", finish));\n      }\n      _this.bitmap = {\n        data: Buffer.alloc(w * h * 4),\n        width: w,\n        height: h\n      };\n      for (var _i3 = 0; _i3 < _this.bitmap.data.length; _i3 += 4) {\n        _this.bitmap.data.writeUInt32BE(_this._background, _i3);\n      }\n      finish(null, (0, _assertThisInitialized2[\"default\"])(_this));\n    } else if ((0, _typeof2[\"default\"])(args[0]) === \"object\" && args[0].url) {\n      cb = args[1] || noop;\n      if (typeof cb !== \"function\") {\n        return (0, _possibleConstructorReturn2[\"default\"])(_this, _utils.throwError.call((0, _assertThisInitialized2[\"default\"])(_this), \"cb must be a function\", finish));\n      }\n      loadFromURL(args[0], function (err, data) {\n        if (err) {\n          return _utils.throwError.call((0, _assertThisInitialized2[\"default\"])(_this), err, finish);\n        }\n        _this.parseBitmap(data, args[0].url, finish);\n      });\n    } else if (args[0] instanceof Jimp) {\n      // clone an existing Jimp\n      var original = args[0];\n      cb = args[1];\n      if (typeof cb === \"undefined\") {\n        cb = noop;\n      }\n      if (typeof cb !== \"function\") {\n        return (0, _possibleConstructorReturn2[\"default\"])(_this, _utils.throwError.call((0, _assertThisInitialized2[\"default\"])(_this), \"cb must be a function\", finish));\n      }\n      _this.bitmap = {\n        data: Buffer.from(original.bitmap.data),\n        width: original.bitmap.width,\n        height: original.bitmap.height\n      };\n      _this._quality = original._quality;\n      _this._deflateLevel = original._deflateLevel;\n      _this._deflateStrategy = original._deflateStrategy;\n      _this._filterType = original._filterType;\n      _this._rgba = original._rgba;\n      _this._background = original._background;\n      _this._originalMime = original._originalMime;\n      finish(null, (0, _assertThisInitialized2[\"default\"])(_this));\n    } else if (isRawRGBAData(args[0])) {\n      var imageData = args[0];\n      cb = args[1] || noop;\n      var isRGBA = imageData.width * imageData.height * 4 === imageData.data.length;\n      var buffer = isRGBA ? Buffer.from(imageData.data) : makeRGBABufferFromRGB(imageData.data);\n      _this.bitmap = {\n        data: buffer,\n        width: imageData.width,\n        height: imageData.height\n      };\n      finish(null, (0, _assertThisInitialized2[\"default\"])(_this));\n    } else if (typeof args[0] === \"string\") {\n      // read from a path\n      var path = args[0];\n      cb = args[1];\n      if (typeof cb === \"undefined\") {\n        cb = noop;\n      }\n      if (typeof cb !== \"function\") {\n        return (0, _possibleConstructorReturn2[\"default\"])(_this, _utils.throwError.call((0, _assertThisInitialized2[\"default\"])(_this), \"cb must be a function\", finish));\n      }\n      loadBufferFromPath(path, function (err, data) {\n        if (err) {\n          return _utils.throwError.call((0, _assertThisInitialized2[\"default\"])(_this), err, finish);\n        }\n        _this.parseBitmap(data, path, finish);\n      });\n    } else if ((0, _typeof2[\"default\"])(args[0]) === \"object\" && Buffer.isBuffer(args[0])) {\n      // read from a buffer\n      var data = args[0];\n      cb = args[1];\n      if (typeof cb !== \"function\") {\n        return (0, _possibleConstructorReturn2[\"default\"])(_this, _utils.throwError.call((0, _assertThisInitialized2[\"default\"])(_this), \"cb must be a function\", finish));\n      }\n      _this.parseBitmap(data, null, finish);\n    } else {\n      // Allow client libs to add new ways to build a Jimp object.\n      // Extra constructors must be added by `Jimp.appendConstructorOption()`\n      cb = args[args.length - 1];\n      if (typeof cb !== \"function\") {\n        // TODO: try to solve the args after cb problem.\n        cb = args[args.length - 2];\n        if (typeof cb !== \"function\") {\n          cb = noop;\n        }\n      }\n      var extraConstructor = Jimp.__extraConstructors.find(function (c) {\n        return c.test.apply(c, args);\n      });\n      if (extraConstructor) {\n        new Promise(function (resolve, reject) {\n          var _extraConstructor$run;\n          (_extraConstructor$run = extraConstructor.run).call.apply(_extraConstructor$run, [(0, _assertThisInitialized2[\"default\"])(_this), resolve, reject].concat(args));\n        }).then(function () {\n          return finish(null, (0, _assertThisInitialized2[\"default\"])(_this));\n        })[\"catch\"](finish);\n      } else {\n        return (0, _possibleConstructorReturn2[\"default\"])(_this, _utils.throwError.call((0, _assertThisInitialized2[\"default\"])(_this), \"No matching constructor overloading was found. \" + \"Please see the docs for how to call the Jimp constructor.\", finish));\n      }\n    }\n    return _this;\n  }\n  /**\n   * Parse a bitmap with the loaded image types.\n   *\n   * @param {Buffer} data raw image data\n   * @param {string} path optional path to file\n   * @param {function(Error, Jimp)} finish (optional) a callback for when complete\n   * @memberof Jimp\n   */\n\n  (0, _createClass2[\"default\"])(Jimp, [{\n    key: \"parseBitmap\",\n    value: function parseBitmap(data, path, finish) {\n      _imageBitmap.parseBitmap.call(this, data, null, finish);\n    }\n    /**\n     * Sets the type of the image (RGB or RGBA) when saving in a format that supports transparency (default is RGBA)\n     * @param {boolean} bool A Boolean, true to use RGBA or false to use RGB\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp} this for chaining of methods\n     */\n  }, {\n    key: \"rgba\",\n    value: function rgba(bool, cb) {\n      if (typeof bool !== \"boolean\") {\n        return _utils.throwError.call(this, \"bool must be a boolean, true for RGBA or false for RGB\", cb);\n      }\n      this._rgba = bool;\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    }\n    /**\n     * Emit for multiple listeners\n     * @param {string} methodName name of the method to emit an error for\n     * @param {string} eventName name of the eventName to emit an error for\n     * @param {object} data to emit\n     */\n  }, {\n    key: \"emitMulti\",\n    value: function emitMulti(methodName, eventName) {\n      var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      data = Object.assign(data, {\n        methodName: methodName,\n        eventName: eventName\n      });\n      this.emit(\"any\", data);\n      if (methodName) {\n        this.emit(methodName, data);\n      }\n      this.emit(eventName, data);\n    }\n  }, {\n    key: \"emitError\",\n    value: function emitError(methodName, err) {\n      this.emitMulti(methodName, \"error\", err);\n    }\n    /**\n     * Get the current height of the image\n     * @return {number} height of the image\n     */\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return this.bitmap.height;\n    }\n    /**\n     * Get the current width of the image\n     * @return {number} width of the image\n     */\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return this.bitmap.width;\n    }\n    /**\n     * Nicely format Jimp object when sent to the console e.g. console.log(image)\n     * @returns {string} pretty printed\n     */\n  }, {\n    key: \"inspect\",\n    value: function inspect() {\n      return \"<Jimp \" + (this.bitmap === emptyBitmap ? \"pending...\" : this.bitmap.width + \"x\" + this.bitmap.height) + \">\";\n    }\n    /**\n     * Nicely format Jimp object when converted to a string\n     * @returns {string} pretty printed\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"[object Jimp]\";\n    }\n    /**\n     * Returns the original MIME of the image (default: \"image/png\")\n     * @returns {string} the MIME\n     */\n  }, {\n    key: \"getMIME\",\n    value: function getMIME() {\n      var mime = this._originalMime || Jimp.MIME_PNG;\n      return mime;\n    }\n    /**\n     * Returns the appropriate file extension for the original MIME of the image (default: \"png\")\n     * @returns {string} the file extension\n     */\n  }, {\n    key: \"getExtension\",\n    value: function getExtension() {\n      var mime = this.getMIME();\n      return MIME.getExtension(mime);\n    }\n    /**\n     * Writes the image to a file\n     * @param {string} path a path to the destination file\n     * @param {function(Error, Jimp)} cb (optional) a function to call when the image is saved to disk\n     * @returns {Jimp} this for chaining of methods\n     */\n  }, {\n    key: \"write\",\n    value: function write(path, cb) {\n      var _this2 = this;\n      if (!_fs[\"default\"] || !_fs[\"default\"].createWriteStream) {\n        throw new Error(\"Cant access the filesystem. You can use the getBase64 method.\");\n      }\n      if (typeof path !== \"string\") {\n        return _utils.throwError.call(this, \"path must be a string\", cb);\n      }\n      if (typeof cb === \"undefined\") {\n        cb = noop;\n      }\n      if (typeof cb !== \"function\") {\n        return _utils.throwError.call(this, \"cb must be a function\", cb);\n      }\n      var mime = MIME.getType(path) || this.getMIME();\n      var pathObj = _path[\"default\"].parse(path);\n      if (pathObj.dir) {\n        _mkdirp[\"default\"].sync(pathObj.dir);\n      }\n      this.getBuffer(mime, function (err, buffer) {\n        if (err) {\n          return _utils.throwError.call(_this2, err, cb);\n        }\n        var stream = _fs[\"default\"].createWriteStream(path);\n        stream.on(\"open\", function () {\n          stream.write(buffer);\n          stream.end();\n        }).on(\"error\", function (err) {\n          return _utils.throwError.call(_this2, err, cb);\n        });\n        stream.on(\"finish\", function () {\n          cb.call(_this2, null, _this2);\n        });\n      });\n      return this;\n    }\n  }, {\n    key: \"getBase64\",\n    /**\n     * Converts the image to a base 64 string\n     * @param {string} mime the mime type of the image data to be created\n     * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n     * @returns {Jimp} this for chaining of methods\n     */\n    value: function getBase64(mime, cb) {\n      if (mime === Jimp.AUTO) {\n        // allow auto MIME detection\n        mime = this.getMIME();\n      }\n      if (typeof mime !== \"string\") {\n        return _utils.throwError.call(this, \"mime must be a string\", cb);\n      }\n      if (typeof cb !== \"function\") {\n        return _utils.throwError.call(this, \"cb must be a function\", cb);\n      }\n      this.getBuffer(mime, function (err, data) {\n        if (err) {\n          return _utils.throwError.call(this, err, cb);\n        }\n        var src = \"data:\" + mime + \";base64,\" + data.toString(\"base64\");\n        cb.call(this, null, src);\n      });\n      return this;\n    }\n  }, {\n    key: \"hash\",\n    /**\n     * Generates a perceptual hash of the image <https://en.wikipedia.org/wiki/Perceptual_hashing>. And pads the string. Can configure base.\n     * @param {number} base (optional) a number between 2 and 64 representing the base for the hash (e.g. 2 is binary, 10 is decimal, 16 is hex, 64 is base 64). Defaults to 64.\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {string} a string representing the hash\n     */\n    value: function hash(base, cb) {\n      base = base || 64;\n      if (typeof base === \"function\") {\n        cb = base;\n        base = 64;\n      }\n      if (typeof base !== \"number\") {\n        return _utils.throwError.call(this, \"base must be a number\", cb);\n      }\n      if (base < 2 || base > 64) {\n        return _utils.throwError.call(this, \"base must be a number between 2 and 64\", cb);\n      }\n      var hash = this.pHash();\n      hash = (0, _anyBase[\"default\"])(_anyBase[\"default\"].BIN, alphabet.slice(0, base))(hash);\n      while (hash.length < maxHashLength[base]) {\n        hash = \"0\" + hash; // pad out with leading zeros\n      }\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, hash);\n      }\n      return hash;\n    }\n    /**\n     * Calculates the perceptual hash\n     * @returns {number} the perceptual hash\n     */\n  }, {\n    key: \"pHash\",\n    value: function pHash() {\n      var pHash = new _phash[\"default\"]();\n      return pHash.getHash(this);\n    }\n    /**\n     * Calculates the hamming distance of the current image and a hash based on their perceptual hash\n     * @param {hash} compareHash hash to compare to\n     * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n     */\n  }, {\n    key: \"distanceFromHash\",\n    value: function distanceFromHash(compareHash) {\n      var pHash = new _phash[\"default\"]();\n      var currentHash = pHash.getHash(this);\n      return pHash.distance(currentHash, compareHash);\n    }\n    /**\n     * Converts the image to a buffer\n     * @param {string} mime the mime type of the image buffer to be created\n     * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n     * @returns {Jimp} this for chaining of methods\n     */\n  }, {\n    key: \"getPixelIndex\",\n    /**\n     * Returns the offset of a pixel in the bitmap buffer\n     * @param {number} x the x coordinate\n     * @param {number} y the y coordinate\n     * @param {number} edgeHandling (optional) define how to sum pixels from outside the border\n     * @param {number} cb (optional) a callback for when complete\n     * @returns {number} the index of the pixel or -1 if not found\n     */\n    value: function getPixelIndex(x, y, edgeHandling, cb) {\n      var xi;\n      var yi;\n      if (typeof edgeHandling === \"function\" && typeof cb === \"undefined\") {\n        cb = edgeHandling;\n        edgeHandling = null;\n      }\n      if (!edgeHandling) {\n        edgeHandling = Jimp.EDGE_EXTEND;\n      }\n      if (typeof x !== \"number\" || typeof y !== \"number\") {\n        return _utils.throwError.call(this, \"x and y must be numbers\", cb);\n      } // round input\n\n      x = Math.round(x);\n      y = Math.round(y);\n      xi = x;\n      yi = y;\n      if (edgeHandling === Jimp.EDGE_EXTEND) {\n        if (x < 0) xi = 0;\n        if (x >= this.bitmap.width) xi = this.bitmap.width - 1;\n        if (y < 0) yi = 0;\n        if (y >= this.bitmap.height) yi = this.bitmap.height - 1;\n      }\n      if (edgeHandling === Jimp.EDGE_WRAP) {\n        if (x < 0) {\n          xi = this.bitmap.width + x;\n        }\n        if (x >= this.bitmap.width) {\n          xi = x % this.bitmap.width;\n        }\n        if (y < 0) {\n          xi = this.bitmap.height + y;\n        }\n        if (y >= this.bitmap.height) {\n          yi = y % this.bitmap.height;\n        }\n      }\n      var i = this.bitmap.width * yi + xi << 2; // if out of bounds index is -1\n\n      if (xi < 0 || xi >= this.bitmap.width) {\n        i = -1;\n      }\n      if (yi < 0 || yi >= this.bitmap.height) {\n        i = -1;\n      }\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, i);\n      }\n      return i;\n    }\n    /**\n     * Returns the hex colour value of a pixel\n     * @param {number} x the x coordinate\n     * @param {number} y the y coordinate\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {number} the color of the pixel\n     */\n  }, {\n    key: \"getPixelColor\",\n    value: function getPixelColor(x, y, cb) {\n      if (typeof x !== \"number\" || typeof y !== \"number\") return _utils.throwError.call(this, \"x and y must be numbers\", cb); // round input\n\n      x = Math.round(x);\n      y = Math.round(y);\n      var idx = this.getPixelIndex(x, y);\n      var hex = this.bitmap.data.readUInt32BE(idx);\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, hex);\n      }\n      return hex;\n    }\n  }, {\n    key: \"setPixelColor\",\n    /**\n     * Returns the hex colour value of a pixel\n     * @param {number} hex color to set\n     * @param {number} x the x coordinate\n     * @param {number} y the y coordinate\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {number} the index of the pixel or -1 if not found\n     */\n    value: function setPixelColor(hex, x, y, cb) {\n      if (typeof hex !== \"number\" || typeof x !== \"number\" || typeof y !== \"number\") return _utils.throwError.call(this, \"hex, x and y must be numbers\", cb); // round input\n\n      x = Math.round(x);\n      y = Math.round(y);\n      var idx = this.getPixelIndex(x, y);\n      this.bitmap.data.writeUInt32BE(hex, idx);\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    }\n  }, {\n    key: \"hasAlpha\",\n    /**\n     * Determine if the image contains opaque pixels.\n     * @return {boolean} hasAlpha whether the image contains opaque pixels\n     */\n    value: function hasAlpha() {\n      for (var yIndex = 0; yIndex < this.bitmap.height; yIndex++) {\n        for (var xIndex = 0; xIndex < this.bitmap.width; xIndex++) {\n          var idx = this.bitmap.width * yIndex + xIndex << 2;\n          var alpha = this.bitmap.data[idx + 3];\n          if (alpha !== 0xff) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n    /**\n     * Iterate scan through a region of the bitmap\n     * @param {number} x the x coordinate to begin the scan at\n     * @param {number} y the y coordinate to begin the scan at\n     * @param w the width of the scan region\n     * @param h the height of the scan region\n     * @returns {IterableIterator<{x: number, y: number, idx: number, image: Jimp}>}\n     */\n  }, {\n    key: \"scanIterator\",\n    value: function scanIterator(x, y, w, h) {\n      if (typeof x !== \"number\" || typeof y !== \"number\") {\n        return _utils.throwError.call(this, \"x and y must be numbers\");\n      }\n      if (typeof w !== \"number\" || typeof h !== \"number\") {\n        return _utils.throwError.call(this, \"w and h must be numbers\");\n      }\n      return (0, _utils.scanIterator)(this, x, y, w, h);\n    }\n  }]);\n  return Jimp;\n}(_events[\"default\"]);\nfunction addConstants(constants) {\n  var jimpInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Jimp;\n  Object.entries(constants).forEach(function (_ref) {\n    var _ref2 = (0, _slicedToArray2[\"default\"])(_ref, 2),\n      name = _ref2[0],\n      value = _ref2[1];\n    jimpInstance[name] = value;\n  });\n}\nfunction addJimpMethods(methods) {\n  var jimpInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Jimp;\n  Object.entries(methods).forEach(function (_ref3) {\n    var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 2),\n      name = _ref4[0],\n      value = _ref4[1];\n    jimpInstance.prototype[name] = value;\n  });\n}\naddConstants(constants);\naddJimpMethods({\n  composite: _composite[\"default\"]\n});\nJimp.__extraConstructors = [];\n/**\n * Allow client libs to add new ways to build a Jimp object.\n * @param {string} name identify the extra constructor.\n * @param {function} test a function that returns true when it accepts the arguments passed to the main constructor.\n * @param {function} run where the magic happens.\n */\n\nJimp.appendConstructorOption = function (name, test, run) {\n  Jimp.__extraConstructors.push({\n    name: name,\n    test: test,\n    run: run\n  });\n};\n/**\n * Read an image from a file or a Buffer. Takes the same args as the constructor\n * @returns {Promise} a promise\n */\n\nJimp.read = function () {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n  return new Promise(function (resolve, reject) {\n    // eslint-disable-next-line no-new\n    (0, _construct2[\"default\"])(Jimp, args.concat([function (err, image) {\n      if (err) reject(err);else resolve(image);\n    }]));\n  });\n};\nJimp.create = Jimp.read;\n/**\n * A static helper method that converts RGBA values to a single integer value\n * @param {number} r the red value (0-255)\n * @param {number} g the green value (0-255)\n * @param {number} b the blue value (0-255)\n * @param {number} a the alpha value (0-255)\n * @param {function(Error, Jimp)} cb (optional) A callback for when complete\n * @returns {number} an single integer colour value\n */\n\nJimp.rgbaToInt = function (r, g, b, a, cb) {\n  if (typeof r !== \"number\" || typeof g !== \"number\" || typeof b !== \"number\" || typeof a !== \"number\") {\n    return _utils.throwError.call(this, \"r, g, b and a must be numbers\", cb);\n  }\n  if (r < 0 || r > 255) {\n    return _utils.throwError.call(this, \"r must be between 0 and 255\", cb);\n  }\n  if (g < 0 || g > 255) {\n    _utils.throwError.call(this, \"g must be between 0 and 255\", cb);\n  }\n  if (b < 0 || b > 255) {\n    return _utils.throwError.call(this, \"b must be between 0 and 255\", cb);\n  }\n  if (a < 0 || a > 255) {\n    return _utils.throwError.call(this, \"a must be between 0 and 255\", cb);\n  }\n  r = Math.round(r);\n  b = Math.round(b);\n  g = Math.round(g);\n  a = Math.round(a);\n  var i = r * Math.pow(256, 3) + g * Math.pow(256, 2) + b * Math.pow(256, 1) + a * Math.pow(256, 0);\n  if ((0, _utils.isNodePattern)(cb)) {\n    cb.call(this, null, i);\n  }\n  return i;\n};\n/**\n * A static helper method that converts RGBA values to a single integer value\n * @param {number} i a single integer value representing an RGBA colour (e.g. 0xFF0000FF for red)\n * @param {function(Error, Jimp)} cb (optional) A callback for when complete\n * @returns {object} an object with the properties r, g, b and a representing RGBA values\n */\n\nJimp.intToRGBA = function (i, cb) {\n  if (typeof i !== \"number\") {\n    return _utils.throwError.call(this, \"i must be a number\", cb);\n  }\n  var rgba = {};\n  rgba.r = Math.floor(i / Math.pow(256, 3));\n  rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));\n  rgba.b = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1));\n  rgba.a = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0));\n  if ((0, _utils.isNodePattern)(cb)) {\n    cb.call(this, null, rgba);\n  }\n  return rgba;\n};\n/**\n * Converts a css color (Hex, 8-digit (RGBA) Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to a hex number\n * @param {string} cssColor a number\n * @returns {number} a hex number representing a color\n */\n\nJimp.cssColorToHex = function (cssColor) {\n  cssColor = cssColor || 0; // 0, null, undefined, NaN\n\n  if (typeof cssColor === \"number\") return Number(cssColor);\n  return parseInt((0, _tinycolor[\"default\"])(cssColor).toHex8(), 16);\n};\n/**\n * Limits a number to between 0 or 255\n * @param {number} n a number\n * @returns {number} the number limited to between 0 or 255\n */\n\nJimp.limit255 = function (n) {\n  n = Math.max(n, 0);\n  n = Math.min(n, 255);\n  return n;\n};\n/**\n * Diffs two images and returns\n * @param {Jimp} img1 a Jimp image to compare\n * @param {Jimp} img2 a Jimp image to compare\n * @param {number} threshold (optional) a number, 0 to 1, the smaller the value the more sensitive the comparison (default: 0.1)\n * @returns {object} an object { percent: percent similar, diff: a Jimp image highlighting differences }\n */\n\nJimp.diff = function (img1, img2) {\n  var threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;\n  if (!(img1 instanceof Jimp) || !(img2 instanceof Jimp)) return _utils.throwError.call(this, \"img1 and img2 must be an Jimp images\");\n  var bmp1 = img1.bitmap;\n  var bmp2 = img2.bitmap;\n  if (bmp1.width !== bmp2.width || bmp1.height !== bmp2.height) {\n    if (bmp1.width * bmp1.height > bmp2.width * bmp2.height) {\n      // img1 is bigger\n      img1 = img1.cloneQuiet().resize(bmp2.width, bmp2.height);\n    } else {\n      // img2 is bigger (or they are the same in area)\n      img2 = img2.cloneQuiet().resize(bmp1.width, bmp1.height);\n    }\n  }\n  if (typeof threshold !== \"number\" || threshold < 0 || threshold > 1) {\n    return _utils.throwError.call(this, \"threshold must be a number between 0 and 1\");\n  }\n  var diff = new Jimp(bmp1.width, bmp1.height, 0xffffffff);\n  var numDiffPixels = (0, _pixelmatch[\"default\"])(bmp1.data, bmp2.data, diff.bitmap.data, diff.bitmap.width, diff.bitmap.height, {\n    threshold: threshold\n  });\n  return {\n    percent: numDiffPixels / (diff.bitmap.width * diff.bitmap.height),\n    image: diff\n  };\n};\n/**\n * Calculates the hamming distance of two images based on their perceptual hash\n * @param {Jimp} img1 a Jimp image to compare\n * @param {Jimp} img2 a Jimp image to compare\n * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n */\n\nJimp.distance = function (img1, img2) {\n  var phash = new _phash[\"default\"]();\n  var hash1 = phash.getHash(img1);\n  var hash2 = phash.getHash(img2);\n  return phash.distance(hash1, hash2);\n};\n/**\n * Calculates the hamming distance of two images based on their perceptual hash\n * @param {hash} hash1 a pHash\n * @param {hash} hash2 a pHash\n * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n */\n\nJimp.compareHashes = function (hash1, hash2) {\n  var phash = new _phash[\"default\"]();\n  return phash.distance(hash1, hash2);\n};\n/**\n * Compute color difference\n * 0 means no difference, 1 means maximum difference.\n * @param {number} rgba1:    first color to compare.\n * @param {number} rgba2:    second color to compare.\n * Both parameters must be an color object {r:val, g:val, b:val, a:val}\n * Where `a` is optional and `val` is an integer between 0 and 255.\n * @returns {number} float between 0 and 1.\n */\n\nJimp.colorDiff = function (rgba1, rgba2) {\n  var pow = function pow(n) {\n    return Math.pow(n, 2);\n  };\n  var max = Math.max;\n  var maxVal = 255 * 255 * 3;\n  if (rgba1.a !== 0 && !rgba1.a) {\n    rgba1.a = 255;\n  }\n  if (rgba2.a !== 0 && !rgba2.a) {\n    rgba2.a = 255;\n  }\n  return (max(pow(rgba1.r - rgba2.r), pow(rgba1.r - rgba2.r - rgba1.a + rgba2.a)) + max(pow(rgba1.g - rgba2.g), pow(rgba1.g - rgba2.g - rgba1.a + rgba2.a)) + max(pow(rgba1.b - rgba2.b), pow(rgba1.b - rgba2.b - rgba1.a + rgba2.a))) / maxVal;\n};\n/**\n * Helper to create Jimp methods that emit events before and after its execution.\n * @param {string} methodName   The name to be appended to Jimp prototype.\n * @param {string} evName       The event name to be called.\n *                     It will be prefixed by `before-` and emitted when on method call.\n *                     It will be appended by `ed` and emitted after the method run.\n * @param {function} method       A function implementing the method itself.\n * It will also create a quiet version that will not emit events, to not\n * mess the user code with many `changed` event calls. You can call with\n * `methodName + \"Quiet\"`.\n *\n * The emitted event comes with a object parameter to the listener with the\n * `methodName` as one attribute.\n */\n\nfunction jimpEvMethod(methodName, evName, method) {\n  var evNameBefore = \"before-\" + evName;\n  var evNameAfter = evName.replace(/e$/, \"\") + \"ed\";\n  Jimp.prototype[methodName] = function () {\n    var wrappedCb;\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    var cb = args[method.length - 1];\n    var jimpInstance = this;\n    if (typeof cb === \"function\") {\n      wrappedCb = function wrappedCb() {\n        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n        var err = args[0],\n          data = args[1];\n        if (err) {\n          jimpInstance.emitError(methodName, err);\n        } else {\n          jimpInstance.emitMulti(methodName, evNameAfter, (0, _defineProperty2[\"default\"])({}, methodName, data));\n        }\n        cb.apply(this, args);\n      };\n      args[args.length - 1] = wrappedCb;\n    } else {\n      wrappedCb = false;\n    }\n    this.emitMulti(methodName, evNameBefore);\n    var result;\n    try {\n      result = method.apply(this, args);\n      if (!wrappedCb) {\n        this.emitMulti(methodName, evNameAfter, (0, _defineProperty2[\"default\"])({}, methodName, result));\n      }\n    } catch (error) {\n      error.methodName = methodName;\n      this.emitError(methodName, error);\n    }\n    return result;\n  };\n  Jimp.prototype[methodName + \"Quiet\"] = method;\n}\n/**\n * Creates a new image that is a clone of this one.\n * @param {function(Error, Jimp)} cb (optional) A callback for when complete\n * @returns the new image\n */\n\njimpEvMethod(\"clone\", \"clone\", function (cb) {\n  var clone = new Jimp(this);\n  if ((0, _utils.isNodePattern)(cb)) {\n    cb.call(clone, null, clone);\n  }\n  return clone;\n});\n/**\n * Simplify jimpEvMethod call for the common `change` evName.\n * @param {string} methodName name of the method\n * @param {function} method to watch changes for\n */\n\nfunction jimpEvChange(methodName, method) {\n  jimpEvMethod(methodName, \"change\", method);\n}\n/**\n * Sets the type of the image (RGB or RGBA) when saving as PNG format (default is RGBA)\n * @param b A Boolean, true to use RGBA or false to use RGB\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n\njimpEvChange(\"background\", function (hex, cb) {\n  if (typeof hex !== \"number\") {\n    return _utils.throwError.call(this, \"hex must be a hexadecimal rgba value\", cb);\n  }\n  this._background = hex;\n  if ((0, _utils.isNodePattern)(cb)) {\n    cb.call(this, null, this);\n  }\n  return this;\n});\n/**\n * Scans through a region of the bitmap, calling a function for each pixel.\n * @param {number} x the x coordinate to begin the scan at\n * @param {number} y the y coordinate to begin the scan at\n * @param w the width of the scan region\n * @param h the height of the scan region\n * @param f a function to call on even pixel; the (x, y) position of the pixel\n * and the index of the pixel in the bitmap buffer are passed to the function\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n\njimpEvChange(\"scan\", function (x, y, w, h, f, cb) {\n  if (typeof x !== \"number\" || typeof y !== \"number\") {\n    return _utils.throwError.call(this, \"x and y must be numbers\", cb);\n  }\n  if (typeof w !== \"number\" || typeof h !== \"number\") {\n    return _utils.throwError.call(this, \"w and h must be numbers\", cb);\n  }\n  if (typeof f !== \"function\") {\n    return _utils.throwError.call(this, \"f must be a function\", cb);\n  }\n  var result = (0, _utils.scan)(this, x, y, w, h, f);\n  if ((0, _utils.isNodePattern)(cb)) {\n    cb.call(this, null, result);\n  }\n  return result;\n});\nif (process.env.ENVIRONMENT === \"BROWSER\") {\n  // For use in a web browser or web worker\n\n  /* global self */\n  var gl;\n  if (typeof window !== \"undefined\" && (typeof window === \"undefined\" ? \"undefined\" : (0, _typeof2[\"default\"])(window)) === \"object\") {\n    gl = window;\n  }\n  if (typeof self !== \"undefined\" && (typeof self === \"undefined\" ? \"undefined\" : (0, _typeof2[\"default\"])(self)) === \"object\") {\n    gl = self;\n  }\n  gl.Jimp = Jimp;\n  gl.Buffer = Buffer;\n}\nvar _default = Jimp;\nexports[\"default\"] = _default;","map":{"version":3,"names":["_fs","_interopRequireDefault","require","_path","_events","_utils","_anyBase","_mkdirp","_pixelmatch","_tinycolor","_phash","_request","_composite","_promisify","MIME","_interopRequireWildcard","_imageBitmap","constants","alphabet","maxHashLength","NaN","i","maxHash","BIN","slice","Array","join","push","length","noop","isArrayBuffer","test","Object","prototype","toString","call","toLowerCase","indexOf","bufferFromArrayBuffer","arrayBuffer","buffer","Buffer","alloc","byteLength","view","Uint8Array","_i","loadFromURL","options","cb","err","response","data","headers","url","location","_typeof2","isBuffer","msg","statusCode","Error","loadBufferFromPath","src","readFile","match","isRawRGBAData","obj","width","height","Uint8ClampedArray","makeRGBABufferFromRGB","rgbaBuffer","allocUnsafe","j","_i2","emptyBitmap","Jimp","_this","_len","arguments","args","_key","_classCallCheck2","_possibleConstructorReturn2","_getPrototypeOf2","_defineProperty2","_assertThisInitialized2","MIME_PNG","path","write","mime","getBase64","getBuffer","getBufferAsync","getPixelColor","setPixelColor","jimpInstance","finish","_len2","_key2","evData","methodName","setTimeout","_cb","emitError","emitMulti","apply","concat","parseInt","w","h","_background","cssColorToHex","throwError","bitmap","_i3","writeUInt32BE","parseBitmap","original","from","_quality","_deflateLevel","_deflateStrategy","_filterType","_rgba","_originalMime","imageData","isRGBA","extraConstructor","__extraConstructors","find","c","Promise","resolve","reject","_extraConstructor$run","run","then","bool","isNodePattern","eventName","undefined","assign","emit","getMIME","getExtension","_this2","createWriteStream","getType","pathObj","parse","dir","sync","stream","on","end","AUTO","base","hash","pHash","getHash","compareHash","currentHash","distance","x","y","edgeHandling","xi","yi","EDGE_EXTEND","Math","round","EDGE_WRAP","idx","getPixelIndex","hex","readUInt32BE","yIndex","xIndex","alpha","scanIterator","addConstants","entries","forEach","_ref","_ref2","_slicedToArray2","name","value","addJimpMethods","methods","_ref3","_ref4","composite","appendConstructorOption","read","_len3","_key3","_construct2","image","create","rgbaToInt","r","g","b","a","pow","intToRGBA","rgba","floor","cssColor","Number","toHex8","limit255","n","max","min","diff","img1","img2","threshold","bmp1","bmp2","cloneQuiet","resize","numDiffPixels","percent","phash","hash1","hash2","compareHashes","colorDiff","rgba1","rgba2","maxVal","jimpEvMethod","evName","method","evNameBefore","evNameAfter","replace","wrappedCb","_len4","_key4","_len5","_key5","result","error","clone","jimpEvChange","f","scan","process","env","ENVIRONMENT","gl","window","self"],"sources":["/Users/wolfejam/HEXTRA-3/node_modules/@jimp/core/src/index.js"],"sourcesContent":["import fs from \"fs\";\nimport Path from \"path\";\nimport EventEmitter from \"events\";\n\nimport { isNodePattern, throwError, scan, scanIterator } from \"@jimp/utils\";\nimport anyBase from \"any-base\";\nimport mkdirp from \"mkdirp\";\nimport pixelMatch from \"pixelmatch\";\nimport tinyColor from \"tinycolor2\";\n\nimport ImagePHash from \"./modules/phash\";\nimport request from \"./request\";\n\nimport composite from \"./composite\";\nimport promisify from \"./utils/promisify\";\nimport * as MIME from \"./utils/mime\";\nimport { parseBitmap, getBuffer, getBufferAsync } from \"./utils/image-bitmap\";\nimport * as constants from \"./constants\";\n\nconst alphabet =\n  \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_\";\n\n// an array storing the maximum string length of hashes at various bases\n// 0 and 1 do not exist as possible hash lengths\nconst maxHashLength = [NaN, NaN];\n\nfor (let i = 2; i < 65; i++) {\n  const maxHash = anyBase(\n    anyBase.BIN,\n    alphabet.slice(0, i)\n  )(new Array(64 + 1).join(\"1\"));\n  maxHashLength.push(maxHash.length);\n}\n\n// no operation\nfunction noop() {}\n\n// error checking methods\n\nfunction isArrayBuffer(test) {\n  return (\n    Object.prototype.toString.call(test).toLowerCase().indexOf(\"arraybuffer\") >\n    -1\n  );\n}\n\n// Prepare a Buffer object from the arrayBuffer. Necessary in the browser > node conversion,\n// But this function is not useful when running in node directly\nfunction bufferFromArrayBuffer(arrayBuffer) {\n  const buffer = Buffer.alloc(arrayBuffer.byteLength);\n  const view = new Uint8Array(arrayBuffer);\n\n  for (let i = 0; i < buffer.length; ++i) {\n    buffer[i] = view[i];\n  }\n\n  return buffer;\n}\n\nfunction loadFromURL(options, cb) {\n  request(options, (err, response, data) => {\n    if (err) {\n      return cb(err);\n    }\n\n    if (\"headers\" in response && \"location\" in response.headers) {\n      options.url = response.headers.location;\n      return loadFromURL(options, cb);\n    }\n\n    if (typeof data === \"object\" && Buffer.isBuffer(data)) {\n      return cb(null, data);\n    }\n\n    const msg =\n      \"Could not load Buffer from <\" +\n      options.url +\n      \"> \" +\n      \"(HTTP: \" +\n      response.statusCode +\n      \")\";\n\n    return new Error(msg);\n  });\n}\n\nfunction loadBufferFromPath(src, cb) {\n  if (\n    fs &&\n    typeof fs.readFile === \"function\" &&\n    !src.match(/^(http|ftp)s?:\\/\\/./)\n  ) {\n    fs.readFile(src, cb);\n  } else {\n    loadFromURL({ url: src }, cb);\n  }\n}\n\nfunction isRawRGBAData(obj) {\n  return (\n    obj &&\n    typeof obj === \"object\" &&\n    typeof obj.width === \"number\" &&\n    typeof obj.height === \"number\" &&\n    (Buffer.isBuffer(obj.data) ||\n      obj.data instanceof Uint8Array ||\n      (typeof Uint8ClampedArray === \"function\" &&\n        obj.data instanceof Uint8ClampedArray)) &&\n    (obj.data.length === obj.width * obj.height * 4 ||\n      obj.data.length === obj.width * obj.height * 3)\n  );\n}\n\nfunction makeRGBABufferFromRGB(buffer) {\n  if (buffer.length % 3 !== 0) {\n    throw new Error(\"Buffer length is incorrect\");\n  }\n\n  const rgbaBuffer = Buffer.allocUnsafe((buffer.length / 3) * 4);\n  let j = 0;\n\n  for (let i = 0; i < buffer.length; i++) {\n    rgbaBuffer[j] = buffer[i];\n\n    if ((i + 1) % 3 === 0) {\n      rgbaBuffer[++j] = 255;\n    }\n\n    j++;\n  }\n\n  return rgbaBuffer;\n}\n\nconst emptyBitmap = {\n  data: null,\n  width: null,\n  height: null,\n};\n\n/**\n * Jimp constructor (from a file)\n * @param path a path to the image\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from a url with options)\n * @param options { url, otherOptions}\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from another Jimp image or raw image data)\n * @param image a Jimp image to clone\n * @param {function(Error, Jimp)} cb a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from a Buffer)\n * @param data a Buffer containing the image data\n * @param {function(Error, Jimp)} cb a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (to generate a new image)\n * @param w the width of the image\n * @param h the height of the image\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (to generate a new image)\n * @param w the width of the image\n * @param h the height of the image\n * @param background color to fill the image with\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\nclass Jimp extends EventEmitter {\n  // An object representing a bitmap in memory, comprising:\n  //  - data: a buffer of the bitmap data\n  //  - width: the width of the image in pixels\n  //  - height: the height of the image in pixels\n  bitmap = emptyBitmap;\n\n  // Default colour to use for new pixels\n  _background = 0x00000000;\n\n  // Default MIME is PNG\n  _originalMime = Jimp.MIME_PNG;\n\n  // Exif data for the image\n  _exif = null;\n\n  // Whether Transparency supporting formats will be exported as RGB or RGBA\n  _rgba = true;\n\n  constructor(...args) {\n    super();\n\n    const jimpInstance = this;\n    let cb = noop;\n\n    if (isArrayBuffer(args[0])) {\n      args[0] = bufferFromArrayBuffer(args[0]);\n    }\n\n    function finish(...args) {\n      const [err] = args;\n      const evData = err || {};\n      evData.methodName = \"constructor\";\n\n      setTimeout(() => {\n        // run on next tick.\n        if (err && cb === noop) {\n          jimpInstance.emitError(\"constructor\", err);\n        } else if (!err) {\n          jimpInstance.emitMulti(\"constructor\", \"initialized\");\n        }\n\n        cb.call(jimpInstance, ...args);\n      }, 1);\n    }\n\n    if (\n      (typeof args[0] === \"number\" && typeof args[1] === \"number\") ||\n      (parseInt(args[0], 10) && parseInt(args[1], 10))\n    ) {\n      // create a new image\n      const w = parseInt(args[0], 10);\n      const h = parseInt(args[1], 10);\n      cb = args[2];\n\n      // with a hex color\n      if (typeof args[2] === \"number\") {\n        this._background = args[2];\n        cb = args[3];\n      }\n\n      // with a css color\n      if (typeof args[2] === \"string\") {\n        this._background = Jimp.cssColorToHex(args[2]);\n        cb = args[3];\n      }\n\n      if (typeof cb === \"undefined\") {\n        cb = noop;\n      }\n\n      if (typeof cb !== \"function\") {\n        return throwError.call(this, \"cb must be a function\", finish);\n      }\n\n      this.bitmap = {\n        data: Buffer.alloc(w * h * 4),\n        width: w,\n        height: h,\n      };\n\n      for (let i = 0; i < this.bitmap.data.length; i += 4) {\n        this.bitmap.data.writeUInt32BE(this._background, i);\n      }\n\n      finish(null, this);\n    } else if (typeof args[0] === \"object\" && args[0].url) {\n      cb = args[1] || noop;\n\n      if (typeof cb !== \"function\") {\n        return throwError.call(this, \"cb must be a function\", finish);\n      }\n\n      loadFromURL(args[0], (err, data) => {\n        if (err) {\n          return throwError.call(this, err, finish);\n        }\n\n        this.parseBitmap(data, args[0].url, finish);\n      });\n    } else if (args[0] instanceof Jimp) {\n      // clone an existing Jimp\n      const [original] = args;\n      cb = args[1];\n\n      if (typeof cb === \"undefined\") {\n        cb = noop;\n      }\n\n      if (typeof cb !== \"function\") {\n        return throwError.call(this, \"cb must be a function\", finish);\n      }\n\n      this.bitmap = {\n        data: Buffer.from(original.bitmap.data),\n        width: original.bitmap.width,\n        height: original.bitmap.height,\n      };\n\n      this._quality = original._quality;\n      this._deflateLevel = original._deflateLevel;\n      this._deflateStrategy = original._deflateStrategy;\n      this._filterType = original._filterType;\n      this._rgba = original._rgba;\n      this._background = original._background;\n      this._originalMime = original._originalMime;\n\n      finish(null, this);\n    } else if (isRawRGBAData(args[0])) {\n      const [imageData] = args;\n      cb = args[1] || noop;\n\n      const isRGBA =\n        imageData.width * imageData.height * 4 === imageData.data.length;\n      const buffer = isRGBA\n        ? Buffer.from(imageData.data)\n        : makeRGBABufferFromRGB(imageData.data);\n\n      this.bitmap = {\n        data: buffer,\n        width: imageData.width,\n        height: imageData.height,\n      };\n\n      finish(null, this);\n    } else if (typeof args[0] === \"string\") {\n      // read from a path\n      const path = args[0];\n      cb = args[1];\n\n      if (typeof cb === \"undefined\") {\n        cb = noop;\n      }\n\n      if (typeof cb !== \"function\") {\n        return throwError.call(this, \"cb must be a function\", finish);\n      }\n\n      loadBufferFromPath(path, (err, data) => {\n        if (err) {\n          return throwError.call(this, err, finish);\n        }\n\n        this.parseBitmap(data, path, finish);\n      });\n    } else if (typeof args[0] === \"object\" && Buffer.isBuffer(args[0])) {\n      // read from a buffer\n      const data = args[0];\n      cb = args[1];\n\n      if (typeof cb !== \"function\") {\n        return throwError.call(this, \"cb must be a function\", finish);\n      }\n\n      this.parseBitmap(data, null, finish);\n    } else {\n      // Allow client libs to add new ways to build a Jimp object.\n      // Extra constructors must be added by `Jimp.appendConstructorOption()`\n      cb = args[args.length - 1];\n\n      if (typeof cb !== \"function\") {\n        // TODO: try to solve the args after cb problem.\n        cb = args[args.length - 2];\n\n        if (typeof cb !== \"function\") {\n          cb = noop;\n        }\n      }\n\n      const extraConstructor = Jimp.__extraConstructors.find((c) =>\n        c.test(...args)\n      );\n\n      if (extraConstructor) {\n        new Promise((resolve, reject) => {\n          extraConstructor.run.call(this, resolve, reject, ...args);\n        })\n          .then(() => finish(null, this))\n          .catch(finish);\n      } else {\n        return throwError.call(\n          this,\n          \"No matching constructor overloading was found. \" +\n            \"Please see the docs for how to call the Jimp constructor.\",\n          finish\n        );\n      }\n    }\n  }\n\n  /**\n   * Parse a bitmap with the loaded image types.\n   *\n   * @param {Buffer} data raw image data\n   * @param {string} path optional path to file\n   * @param {function(Error, Jimp)} finish (optional) a callback for when complete\n   * @memberof Jimp\n   */\n  parseBitmap(data, path, finish) {\n    parseBitmap.call(this, data, null, finish);\n  }\n\n  /**\n   * Sets the type of the image (RGB or RGBA) when saving in a format that supports transparency (default is RGBA)\n   * @param {boolean} bool A Boolean, true to use RGBA or false to use RGB\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  rgba(bool, cb) {\n    if (typeof bool !== \"boolean\") {\n      return throwError.call(\n        this,\n        \"bool must be a boolean, true for RGBA or false for RGB\",\n        cb\n      );\n    }\n\n    this._rgba = bool;\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  }\n\n  /**\n   * Emit for multiple listeners\n   * @param {string} methodName name of the method to emit an error for\n   * @param {string} eventName name of the eventName to emit an error for\n   * @param {object} data to emit\n   */\n  emitMulti(methodName, eventName, data = {}) {\n    data = Object.assign(data, { methodName, eventName });\n    this.emit(\"any\", data);\n\n    if (methodName) {\n      this.emit(methodName, data);\n    }\n\n    this.emit(eventName, data);\n  }\n\n  emitError(methodName, err) {\n    this.emitMulti(methodName, \"error\", err);\n  }\n\n  /**\n   * Get the current height of the image\n   * @return {number} height of the image\n   */\n  getHeight() {\n    return this.bitmap.height;\n  }\n\n  /**\n   * Get the current width of the image\n   * @return {number} width of the image\n   */\n  getWidth() {\n    return this.bitmap.width;\n  }\n\n  /**\n   * Nicely format Jimp object when sent to the console e.g. console.log(image)\n   * @returns {string} pretty printed\n   */\n  inspect() {\n    return (\n      \"<Jimp \" +\n      (this.bitmap === emptyBitmap\n        ? \"pending...\"\n        : this.bitmap.width + \"x\" + this.bitmap.height) +\n      \">\"\n    );\n  }\n\n  /**\n   * Nicely format Jimp object when converted to a string\n   * @returns {string} pretty printed\n   */\n  toString() {\n    return \"[object Jimp]\";\n  }\n\n  /**\n   * Returns the original MIME of the image (default: \"image/png\")\n   * @returns {string} the MIME\n   */\n  getMIME() {\n    const mime = this._originalMime || Jimp.MIME_PNG;\n\n    return mime;\n  }\n\n  /**\n   * Returns the appropriate file extension for the original MIME of the image (default: \"png\")\n   * @returns {string} the file extension\n   */\n  getExtension() {\n    const mime = this.getMIME();\n\n    return MIME.getExtension(mime);\n  }\n\n  /**\n   * Writes the image to a file\n   * @param {string} path a path to the destination file\n   * @param {function(Error, Jimp)} cb (optional) a function to call when the image is saved to disk\n   * @returns {Jimp} this for chaining of methods\n   */\n  write(path, cb) {\n    if (!fs || !fs.createWriteStream) {\n      throw new Error(\n        \"Cant access the filesystem. You can use the getBase64 method.\"\n      );\n    }\n\n    if (typeof path !== \"string\") {\n      return throwError.call(this, \"path must be a string\", cb);\n    }\n\n    if (typeof cb === \"undefined\") {\n      cb = noop;\n    }\n\n    if (typeof cb !== \"function\") {\n      return throwError.call(this, \"cb must be a function\", cb);\n    }\n\n    const mime = MIME.getType(path) || this.getMIME();\n    const pathObj = Path.parse(path);\n\n    if (pathObj.dir) {\n      mkdirp.sync(pathObj.dir);\n    }\n\n    this.getBuffer(mime, (err, buffer) => {\n      if (err) {\n        return throwError.call(this, err, cb);\n      }\n\n      const stream = fs.createWriteStream(path);\n\n      stream\n        .on(\"open\", () => {\n          stream.write(buffer);\n          stream.end();\n        })\n        .on(\"error\", (err) => {\n          return throwError.call(this, err, cb);\n        });\n      stream.on(\"finish\", () => {\n        cb.call(this, null, this);\n      });\n    });\n\n    return this;\n  }\n\n  writeAsync = (path) => promisify(this.write, this, path);\n\n  /**\n   * Converts the image to a base 64 string\n   * @param {string} mime the mime type of the image data to be created\n   * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n   * @returns {Jimp} this for chaining of methods\n   */\n  getBase64(mime, cb) {\n    if (mime === Jimp.AUTO) {\n      // allow auto MIME detection\n      mime = this.getMIME();\n    }\n\n    if (typeof mime !== \"string\") {\n      return throwError.call(this, \"mime must be a string\", cb);\n    }\n\n    if (typeof cb !== \"function\") {\n      return throwError.call(this, \"cb must be a function\", cb);\n    }\n\n    this.getBuffer(mime, function (err, data) {\n      if (err) {\n        return throwError.call(this, err, cb);\n      }\n\n      const src = \"data:\" + mime + \";base64,\" + data.toString(\"base64\");\n      cb.call(this, null, src);\n    });\n\n    return this;\n  }\n\n  getBase64Async = (mime) => promisify(this.getBase64, this, mime);\n\n  /**\n   * Generates a perceptual hash of the image <https://en.wikipedia.org/wiki/Perceptual_hashing>. And pads the string. Can configure base.\n   * @param {number} base (optional) a number between 2 and 64 representing the base for the hash (e.g. 2 is binary, 10 is decimal, 16 is hex, 64 is base 64). Defaults to 64.\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {string} a string representing the hash\n   */\n  hash(base, cb) {\n    base = base || 64;\n\n    if (typeof base === \"function\") {\n      cb = base;\n      base = 64;\n    }\n\n    if (typeof base !== \"number\") {\n      return throwError.call(this, \"base must be a number\", cb);\n    }\n\n    if (base < 2 || base > 64) {\n      return throwError.call(\n        this,\n        \"base must be a number between 2 and 64\",\n        cb\n      );\n    }\n\n    let hash = this.pHash();\n    hash = anyBase(anyBase.BIN, alphabet.slice(0, base))(hash);\n\n    while (hash.length < maxHashLength[base]) {\n      hash = \"0\" + hash; // pad out with leading zeros\n    }\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, hash);\n    }\n\n    return hash;\n  }\n\n  /**\n   * Calculates the perceptual hash\n   * @returns {number} the perceptual hash\n   */\n  pHash() {\n    const pHash = new ImagePHash();\n    return pHash.getHash(this);\n  }\n\n  /**\n   * Calculates the hamming distance of the current image and a hash based on their perceptual hash\n   * @param {hash} compareHash hash to compare to\n   * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n   */\n  distanceFromHash(compareHash) {\n    const pHash = new ImagePHash();\n    const currentHash = pHash.getHash(this);\n\n    return pHash.distance(currentHash, compareHash);\n  }\n\n  /**\n   * Converts the image to a buffer\n   * @param {string} mime the mime type of the image buffer to be created\n   * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n   * @returns {Jimp} this for chaining of methods\n   */\n  getBuffer = getBuffer;\n\n  getBufferAsync = getBufferAsync;\n\n  /**\n   * Returns the offset of a pixel in the bitmap buffer\n   * @param {number} x the x coordinate\n   * @param {number} y the y coordinate\n   * @param {number} edgeHandling (optional) define how to sum pixels from outside the border\n   * @param {number} cb (optional) a callback for when complete\n   * @returns {number} the index of the pixel or -1 if not found\n   */\n  getPixelIndex(x, y, edgeHandling, cb) {\n    let xi;\n    let yi;\n\n    if (typeof edgeHandling === \"function\" && typeof cb === \"undefined\") {\n      cb = edgeHandling;\n      edgeHandling = null;\n    }\n\n    if (!edgeHandling) {\n      edgeHandling = Jimp.EDGE_EXTEND;\n    }\n\n    if (typeof x !== \"number\" || typeof y !== \"number\") {\n      return throwError.call(this, \"x and y must be numbers\", cb);\n    }\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n    xi = x;\n    yi = y;\n\n    if (edgeHandling === Jimp.EDGE_EXTEND) {\n      if (x < 0) xi = 0;\n      if (x >= this.bitmap.width) xi = this.bitmap.width - 1;\n      if (y < 0) yi = 0;\n      if (y >= this.bitmap.height) yi = this.bitmap.height - 1;\n    }\n\n    if (edgeHandling === Jimp.EDGE_WRAP) {\n      if (x < 0) {\n        xi = this.bitmap.width + x;\n      }\n\n      if (x >= this.bitmap.width) {\n        xi = x % this.bitmap.width;\n      }\n\n      if (y < 0) {\n        xi = this.bitmap.height + y;\n      }\n\n      if (y >= this.bitmap.height) {\n        yi = y % this.bitmap.height;\n      }\n    }\n\n    let i = (this.bitmap.width * yi + xi) << 2;\n\n    // if out of bounds index is -1\n    if (xi < 0 || xi >= this.bitmap.width) {\n      i = -1;\n    }\n\n    if (yi < 0 || yi >= this.bitmap.height) {\n      i = -1;\n    }\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, i);\n    }\n\n    return i;\n  }\n\n  /**\n   * Returns the hex colour value of a pixel\n   * @param {number} x the x coordinate\n   * @param {number} y the y coordinate\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {number} the color of the pixel\n   */\n  getPixelColor(x, y, cb) {\n    if (typeof x !== \"number\" || typeof y !== \"number\")\n      return throwError.call(this, \"x and y must be numbers\", cb);\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n\n    const idx = this.getPixelIndex(x, y);\n    const hex = this.bitmap.data.readUInt32BE(idx);\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, hex);\n    }\n\n    return hex;\n  }\n\n  getPixelColour = this.getPixelColor;\n\n  /**\n   * Returns the hex colour value of a pixel\n   * @param {number} hex color to set\n   * @param {number} x the x coordinate\n   * @param {number} y the y coordinate\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {number} the index of the pixel or -1 if not found\n   */\n  setPixelColor(hex, x, y, cb) {\n    if (\n      typeof hex !== \"number\" ||\n      typeof x !== \"number\" ||\n      typeof y !== \"number\"\n    )\n      return throwError.call(this, \"hex, x and y must be numbers\", cb);\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n\n    const idx = this.getPixelIndex(x, y);\n    this.bitmap.data.writeUInt32BE(hex, idx);\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  }\n\n  setPixelColour = this.setPixelColor;\n\n  /**\n   * Determine if the image contains opaque pixels.\n   * @return {boolean} hasAlpha whether the image contains opaque pixels\n   */\n  hasAlpha() {\n    for (let yIndex = 0; yIndex < this.bitmap.height; yIndex++) {\n      for (let xIndex = 0; xIndex < this.bitmap.width; xIndex++) {\n        const idx = (this.bitmap.width * yIndex + xIndex) << 2;\n        const alpha = this.bitmap.data[idx + 3];\n\n        if (alpha !== 0xff) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Iterate scan through a region of the bitmap\n   * @param {number} x the x coordinate to begin the scan at\n   * @param {number} y the y coordinate to begin the scan at\n   * @param w the width of the scan region\n   * @param h the height of the scan region\n   * @returns {IterableIterator<{x: number, y: number, idx: number, image: Jimp}>}\n   */\n  scanIterator(x, y, w, h) {\n    if (typeof x !== \"number\" || typeof y !== \"number\") {\n      return throwError.call(this, \"x and y must be numbers\");\n    }\n\n    if (typeof w !== \"number\" || typeof h !== \"number\") {\n      return throwError.call(this, \"w and h must be numbers\");\n    }\n\n    return scanIterator(this, x, y, w, h);\n  }\n}\n\nexport function addConstants(constants, jimpInstance = Jimp) {\n  Object.entries(constants).forEach(([name, value]) => {\n    jimpInstance[name] = value;\n  });\n}\n\nexport function addJimpMethods(methods, jimpInstance = Jimp) {\n  Object.entries(methods).forEach(([name, value]) => {\n    jimpInstance.prototype[name] = value;\n  });\n}\n\naddConstants(constants);\naddJimpMethods({ composite });\n\nJimp.__extraConstructors = [];\n\n/**\n * Allow client libs to add new ways to build a Jimp object.\n * @param {string} name identify the extra constructor.\n * @param {function} test a function that returns true when it accepts the arguments passed to the main constructor.\n * @param {function} run where the magic happens.\n */\nJimp.appendConstructorOption = function (name, test, run) {\n  Jimp.__extraConstructors.push({ name, test, run });\n};\n\n/**\n * Read an image from a file or a Buffer. Takes the same args as the constructor\n * @returns {Promise} a promise\n */\nJimp.read = function (...args) {\n  return new Promise((resolve, reject) => {\n    // eslint-disable-next-line no-new\n    new Jimp(...args, (err, image) => {\n      if (err) reject(err);\n      else resolve(image);\n    });\n  });\n};\n\nJimp.create = Jimp.read;\n\n/**\n * A static helper method that converts RGBA values to a single integer value\n * @param {number} r the red value (0-255)\n * @param {number} g the green value (0-255)\n * @param {number} b the blue value (0-255)\n * @param {number} a the alpha value (0-255)\n * @param {function(Error, Jimp)} cb (optional) A callback for when complete\n * @returns {number} an single integer colour value\n */\nJimp.rgbaToInt = function (r, g, b, a, cb) {\n  if (\n    typeof r !== \"number\" ||\n    typeof g !== \"number\" ||\n    typeof b !== \"number\" ||\n    typeof a !== \"number\"\n  ) {\n    return throwError.call(this, \"r, g, b and a must be numbers\", cb);\n  }\n\n  if (r < 0 || r > 255) {\n    return throwError.call(this, \"r must be between 0 and 255\", cb);\n  }\n\n  if (g < 0 || g > 255) {\n    throwError.call(this, \"g must be between 0 and 255\", cb);\n  }\n\n  if (b < 0 || b > 255) {\n    return throwError.call(this, \"b must be between 0 and 255\", cb);\n  }\n\n  if (a < 0 || a > 255) {\n    return throwError.call(this, \"a must be between 0 and 255\", cb);\n  }\n\n  r = Math.round(r);\n  b = Math.round(b);\n  g = Math.round(g);\n  a = Math.round(a);\n\n  const i =\n    r * Math.pow(256, 3) +\n    g * Math.pow(256, 2) +\n    b * Math.pow(256, 1) +\n    a * Math.pow(256, 0);\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, i);\n  }\n\n  return i;\n};\n\n/**\n * A static helper method that converts RGBA values to a single integer value\n * @param {number} i a single integer value representing an RGBA colour (e.g. 0xFF0000FF for red)\n * @param {function(Error, Jimp)} cb (optional) A callback for when complete\n * @returns {object} an object with the properties r, g, b and a representing RGBA values\n */\nJimp.intToRGBA = function (i, cb) {\n  if (typeof i !== \"number\") {\n    return throwError.call(this, \"i must be a number\", cb);\n  }\n\n  const rgba = {};\n\n  rgba.r = Math.floor(i / Math.pow(256, 3));\n  rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));\n  rgba.b = Math.floor(\n    (i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) /\n      Math.pow(256, 1)\n  );\n  rgba.a = Math.floor(\n    (i -\n      rgba.r * Math.pow(256, 3) -\n      rgba.g * Math.pow(256, 2) -\n      rgba.b * Math.pow(256, 1)) /\n      Math.pow(256, 0)\n  );\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, rgba);\n  }\n\n  return rgba;\n};\n\n/**\n * Converts a css color (Hex, 8-digit (RGBA) Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to a hex number\n * @param {string} cssColor a number\n * @returns {number} a hex number representing a color\n */\nJimp.cssColorToHex = function (cssColor) {\n  cssColor = cssColor || 0; // 0, null, undefined, NaN\n\n  if (typeof cssColor === \"number\") return Number(cssColor);\n\n  return parseInt(tinyColor(cssColor).toHex8(), 16);\n};\n\n/**\n * Limits a number to between 0 or 255\n * @param {number} n a number\n * @returns {number} the number limited to between 0 or 255\n */\nJimp.limit255 = function (n) {\n  n = Math.max(n, 0);\n  n = Math.min(n, 255);\n\n  return n;\n};\n\n/**\n * Diffs two images and returns\n * @param {Jimp} img1 a Jimp image to compare\n * @param {Jimp} img2 a Jimp image to compare\n * @param {number} threshold (optional) a number, 0 to 1, the smaller the value the more sensitive the comparison (default: 0.1)\n * @returns {object} an object { percent: percent similar, diff: a Jimp image highlighting differences }\n */\nJimp.diff = function (img1, img2, threshold = 0.1) {\n  if (!(img1 instanceof Jimp) || !(img2 instanceof Jimp))\n    return throwError.call(this, \"img1 and img2 must be an Jimp images\");\n\n  const bmp1 = img1.bitmap;\n  const bmp2 = img2.bitmap;\n\n  if (bmp1.width !== bmp2.width || bmp1.height !== bmp2.height) {\n    if (bmp1.width * bmp1.height > bmp2.width * bmp2.height) {\n      // img1 is bigger\n      img1 = img1.cloneQuiet().resize(bmp2.width, bmp2.height);\n    } else {\n      // img2 is bigger (or they are the same in area)\n      img2 = img2.cloneQuiet().resize(bmp1.width, bmp1.height);\n    }\n  }\n\n  if (typeof threshold !== \"number\" || threshold < 0 || threshold > 1) {\n    return throwError.call(this, \"threshold must be a number between 0 and 1\");\n  }\n\n  const diff = new Jimp(bmp1.width, bmp1.height, 0xffffffff);\n\n  const numDiffPixels = pixelMatch(\n    bmp1.data,\n    bmp2.data,\n    diff.bitmap.data,\n    diff.bitmap.width,\n    diff.bitmap.height,\n    { threshold }\n  );\n\n  return {\n    percent: numDiffPixels / (diff.bitmap.width * diff.bitmap.height),\n    image: diff,\n  };\n};\n\n/**\n * Calculates the hamming distance of two images based on their perceptual hash\n * @param {Jimp} img1 a Jimp image to compare\n * @param {Jimp} img2 a Jimp image to compare\n * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n */\nJimp.distance = function (img1, img2) {\n  const phash = new ImagePHash();\n  const hash1 = phash.getHash(img1);\n  const hash2 = phash.getHash(img2);\n\n  return phash.distance(hash1, hash2);\n};\n\n/**\n * Calculates the hamming distance of two images based on their perceptual hash\n * @param {hash} hash1 a pHash\n * @param {hash} hash2 a pHash\n * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n */\nJimp.compareHashes = function (hash1, hash2) {\n  const phash = new ImagePHash();\n\n  return phash.distance(hash1, hash2);\n};\n\n/**\n * Compute color difference\n * 0 means no difference, 1 means maximum difference.\n * @param {number} rgba1:    first color to compare.\n * @param {number} rgba2:    second color to compare.\n * Both parameters must be an color object {r:val, g:val, b:val, a:val}\n * Where `a` is optional and `val` is an integer between 0 and 255.\n * @returns {number} float between 0 and 1.\n */\nJimp.colorDiff = function (rgba1, rgba2) {\n  const pow = (n) => Math.pow(n, 2);\n  const { max } = Math;\n  const maxVal = 255 * 255 * 3;\n\n  if (rgba1.a !== 0 && !rgba1.a) {\n    rgba1.a = 255;\n  }\n\n  if (rgba2.a !== 0 && !rgba2.a) {\n    rgba2.a = 255;\n  }\n\n  return (\n    (max(pow(rgba1.r - rgba2.r), pow(rgba1.r - rgba2.r - rgba1.a + rgba2.a)) +\n      max(pow(rgba1.g - rgba2.g), pow(rgba1.g - rgba2.g - rgba1.a + rgba2.a)) +\n      max(pow(rgba1.b - rgba2.b), pow(rgba1.b - rgba2.b - rgba1.a + rgba2.a))) /\n    maxVal\n  );\n};\n\n/**\n * Helper to create Jimp methods that emit events before and after its execution.\n * @param {string} methodName   The name to be appended to Jimp prototype.\n * @param {string} evName       The event name to be called.\n *                     It will be prefixed by `before-` and emitted when on method call.\n *                     It will be appended by `ed` and emitted after the method run.\n * @param {function} method       A function implementing the method itself.\n * It will also create a quiet version that will not emit events, to not\n * mess the user code with many `changed` event calls. You can call with\n * `methodName + \"Quiet\"`.\n *\n * The emitted event comes with a object parameter to the listener with the\n * `methodName` as one attribute.\n */\nexport function jimpEvMethod(methodName, evName, method) {\n  const evNameBefore = \"before-\" + evName;\n  const evNameAfter = evName.replace(/e$/, \"\") + \"ed\";\n\n  Jimp.prototype[methodName] = function (...args) {\n    let wrappedCb;\n    const cb = args[method.length - 1];\n    const jimpInstance = this;\n\n    if (typeof cb === \"function\") {\n      wrappedCb = function (...args) {\n        const [err, data] = args;\n\n        if (err) {\n          jimpInstance.emitError(methodName, err);\n        } else {\n          jimpInstance.emitMulti(methodName, evNameAfter, {\n            [methodName]: data,\n          });\n        }\n\n        cb.apply(this, args);\n      };\n\n      args[args.length - 1] = wrappedCb;\n    } else {\n      wrappedCb = false;\n    }\n\n    this.emitMulti(methodName, evNameBefore);\n\n    let result;\n\n    try {\n      result = method.apply(this, args);\n\n      if (!wrappedCb) {\n        this.emitMulti(methodName, evNameAfter, {\n          [methodName]: result,\n        });\n      }\n    } catch (error) {\n      error.methodName = methodName;\n      this.emitError(methodName, error);\n    }\n\n    return result;\n  };\n\n  Jimp.prototype[methodName + \"Quiet\"] = method;\n}\n\n/**\n * Creates a new image that is a clone of this one.\n * @param {function(Error, Jimp)} cb (optional) A callback for when complete\n * @returns the new image\n */\njimpEvMethod(\"clone\", \"clone\", function (cb) {\n  const clone = new Jimp(this);\n\n  if (isNodePattern(cb)) {\n    cb.call(clone, null, clone);\n  }\n\n  return clone;\n});\n\n/**\n * Simplify jimpEvMethod call for the common `change` evName.\n * @param {string} methodName name of the method\n * @param {function} method to watch changes for\n */\nexport function jimpEvChange(methodName, method) {\n  jimpEvMethod(methodName, \"change\", method);\n}\n\n/**\n * Sets the type of the image (RGB or RGBA) when saving as PNG format (default is RGBA)\n * @param b A Boolean, true to use RGBA or false to use RGB\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\njimpEvChange(\"background\", function (hex, cb) {\n  if (typeof hex !== \"number\") {\n    return throwError.call(this, \"hex must be a hexadecimal rgba value\", cb);\n  }\n\n  this._background = hex;\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, this);\n  }\n\n  return this;\n});\n\n/**\n * Scans through a region of the bitmap, calling a function for each pixel.\n * @param {number} x the x coordinate to begin the scan at\n * @param {number} y the y coordinate to begin the scan at\n * @param w the width of the scan region\n * @param h the height of the scan region\n * @param f a function to call on even pixel; the (x, y) position of the pixel\n * and the index of the pixel in the bitmap buffer are passed to the function\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\njimpEvChange(\"scan\", function (x, y, w, h, f, cb) {\n  if (typeof x !== \"number\" || typeof y !== \"number\") {\n    return throwError.call(this, \"x and y must be numbers\", cb);\n  }\n\n  if (typeof w !== \"number\" || typeof h !== \"number\") {\n    return throwError.call(this, \"w and h must be numbers\", cb);\n  }\n\n  if (typeof f !== \"function\") {\n    return throwError.call(this, \"f must be a function\", cb);\n  }\n\n  const result = scan(this, x, y, w, h, f);\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, result);\n  }\n\n  return result;\n});\n\nif (process.env.ENVIRONMENT === \"BROWSER\") {\n  // For use in a web browser or web worker\n  /* global self */\n  let gl;\n\n  if (typeof window !== \"undefined\" && typeof window === \"object\") {\n    gl = window;\n  }\n\n  if (typeof self !== \"undefined\" && typeof self === \"object\") {\n    gl = self;\n  }\n\n  gl.Jimp = Jimp;\n  gl.Buffer = Buffer;\n}\n\nexport { addType } from \"./utils/mime\";\n\nexport default Jimp;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}