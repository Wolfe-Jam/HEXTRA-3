{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar _utils = require(\"@jimp/utils\");\n\n/**\n * Get an image's histogram\n * @return {object} An object with an array of color occurrence counts for each channel (r,g,b)\n */\nfunction histogram() {\n  var histogram = {\n    r: new Array(256).fill(0),\n    g: new Array(256).fill(0),\n    b: new Array(256).fill(0)\n  };\n  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, index) {\n    histogram.r[this.bitmap.data[index + 0]]++;\n    histogram.g[this.bitmap.data[index + 1]]++;\n    histogram.b[this.bitmap.data[index + 2]]++;\n  });\n  return histogram;\n}\n/**\n * Normalize values\n * @param  {integer} value Pixel channel value.\n * @param  {integer} min   Minimum value for channel\n * @param  {integer} max   Maximum value for channel\n * @return {integer} normalized values\n */\n\nvar _normalize = function normalize(value, min, max) {\n  return (value - min) * 255 / (max - min);\n};\nvar getBounds = function getBounds(histogramChannel) {\n  return [histogramChannel.findIndex(function (value) {\n    return value > 0;\n  }), 255 - histogramChannel.slice().reverse().findIndex(function (value) {\n    return value > 0;\n  })];\n};\n/**\n * Normalizes the image\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n\nvar _default = function _default() {\n  return {\n    normalize: function normalize(cb) {\n      var h = histogram.call(this); // store bounds (minimum and maximum values)\n\n      var bounds = {\n        r: getBounds(h.r),\n        g: getBounds(h.g),\n        b: getBounds(h.b)\n      }; // apply value transformations\n\n      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        var r = this.bitmap.data[idx + 0];\n        var g = this.bitmap.data[idx + 1];\n        var b = this.bitmap.data[idx + 2];\n        this.bitmap.data[idx + 0] = _normalize(r, bounds.r[0], bounds.r[1]);\n        this.bitmap.data[idx + 1] = _normalize(g, bounds.g[0], bounds.g[1]);\n        this.bitmap.data[idx + 2] = _normalize(b, bounds.b[0], bounds.b[1]);\n      });\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    }\n  };\n};\nexports[\"default\"] = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["_utils","require","histogram","r","Array","fill","g","b","scanQuiet","bitmap","width","height","x","y","index","data","_normalize","normalize","value","min","max","getBounds","histogramChannel","findIndex","slice","reverse","_default","cb","h","call","bounds","idx","isNodePattern"],"sources":["/Users/wolfejam/HEXTRA-3/node_modules/@jimp/plugin-normalize/src/index.js"],"sourcesContent":["import { isNodePattern } from \"@jimp/utils\";\n\n/**\n * Get an image's histogram\n * @return {object} An object with an array of color occurrence counts for each channel (r,g,b)\n */\nfunction histogram() {\n  const histogram = {\n    r: new Array(256).fill(0),\n    g: new Array(256).fill(0),\n    b: new Array(256).fill(0),\n  };\n\n  this.scanQuiet(\n    0,\n    0,\n    this.bitmap.width,\n    this.bitmap.height,\n    function (x, y, index) {\n      histogram.r[this.bitmap.data[index + 0]]++;\n      histogram.g[this.bitmap.data[index + 1]]++;\n      histogram.b[this.bitmap.data[index + 2]]++;\n    }\n  );\n\n  return histogram;\n}\n\n/**\n * Normalize values\n * @param  {integer} value Pixel channel value.\n * @param  {integer} min   Minimum value for channel\n * @param  {integer} max   Maximum value for channel\n * @return {integer} normalized values\n */\nconst normalize = function (value, min, max) {\n  return ((value - min) * 255) / (max - min);\n};\n\nconst getBounds = function (histogramChannel) {\n  return [\n    histogramChannel.findIndex((value) => value > 0),\n    255 -\n      histogramChannel\n        .slice()\n        .reverse()\n        .findIndex((value) => value > 0),\n  ];\n};\n\n/**\n * Normalizes the image\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport default () => ({\n  normalize(cb) {\n    const h = histogram.call(this);\n\n    // store bounds (minimum and maximum values)\n    const bounds = {\n      r: getBounds(h.r),\n      g: getBounds(h.g),\n      b: getBounds(h.b),\n    };\n\n    // apply value transformations\n    this.scanQuiet(\n      0,\n      0,\n      this.bitmap.width,\n      this.bitmap.height,\n      function (x, y, idx) {\n        const r = this.bitmap.data[idx + 0];\n        const g = this.bitmap.data[idx + 1];\n        const b = this.bitmap.data[idx + 2];\n\n        this.bitmap.data[idx + 0] = normalize(r, bounds.r[0], bounds.r[1]);\n        this.bitmap.data[idx + 1] = normalize(g, bounds.g[0], bounds.g[1]);\n        this.bitmap.data[idx + 2] = normalize(b, bounds.b[0], bounds.b[1]);\n      }\n    );\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}